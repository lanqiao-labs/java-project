---
show: step
version: 1.0
enable_checker: true
---

# 后台接口开发实战 3—文件移动、删除、重命名接口开发

## 实验介绍

本节实验带领大家来完成文件的移动、删除、重命名接口开发。

#### 知识点

- 数据结构
- 多线程
- 文件移动，删除，重命名接口开发

#### 开发计划

- 开发内容：文件移动、删除、重命名接口开发。

- 开发耗时：实验预计完成时间为 4~6 小时
- 开发难点：
1. 理解删除文件的原理，逻辑删除和物理删除的区别。
2. 递归算法的实际应用。

## 删除文件接口开发

下图为删除文件流程图，整个删除的过程其实只是做标记，并非真正的删除数据和删除磁盘文件，这样做的目的是为了后续回收站功能扩展。

![图片描述](https://doc.shiyanlou.com/courses/3472/1557563/ffe14fda1acf0aa7063f58676dbd4d51-0/wm)

### Model 层实体类添加

打开 `com.shiyanlou.file.model` 包，并在该包下添加 `RecoveryFile.java` 类，每次删除文件操作都会记录到该表，用于后续文件恢复使用，代码如下：

```java
package com.shiyanlou.file.model;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.Table;

import com.baomidou.mybatisplus.annotation.IdType;
import com.baomidou.mybatisplus.annotation.TableId;
import com.baomidou.mybatisplus.annotation.TableName;

import lombok.Data;

@Data
@Table(name = "recoveryfile")
@Entity
@TableName("recoveryfile")
public class RecoveryFile {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @TableId(type = IdType.AUTO)
    @Column(columnDefinition="bigint(20)")
    private Long recoveryFileId;
    @Column(columnDefinition = "bigint(20)")
    private Long userFileId;
    @Column(columnDefinition="varchar(25)")
    private String deleteTime;
    @Column(columnDefinition = "varchar(50)")
    private String deleteBatchNum;
}
```

打开 `com.shiyanlou.file.model` 包，在 `UserFile.java` 实体类中添加三个属性，代码如下：

```java

@Column(columnDefinition="int(11) comment '删除标志 0-未删除 1-已删除'")
private Integer deleteFlag;

@Column(columnDefinition="varchar(25) comment '删除时间'")
private String deleteTime;

@Column(columnDefinition = "varchar(50) comment '删除批次号'")
private String deleteBatchNum;
```

上面增加了删除文件标识 `deleteFlag`，当我们新增文件或者上传文件的时候，应该将该标志置为 0，删除之后置为 1，因此在之前已经实现了的新增文件夹及上传文件的时候，需要给该字段设置为 0，打开 `FileController.java` 类，修改 `createFile` 接口如下：

```java
...
public RestResult<String> createFile(@RequestBody CreateFileDTO createFileDto,
        @RequestHeader("token") String token) {
    ...
    userFile.setIsDir(1);
    userFile.setUploadTime(DateUtil.getCurrentTime());
    //***修改点***，添加下面这一行代码
    userFile.setDeleteFlag(0);   
    userfileService.save(userFile);
    return RestResult.success();
}
```

打开 `FiletransferServiceImpl.java` 类，修改 `uploadFile` 接口如下：

```java
...
@Override
public void uploadFile(HttpServletRequest request, UploadFileDTO uploadFileDto, Long userId) {
            ...
            userFile.setFileName(uploadFile.getFileName());
            userFile.setFilePath(uploadFileDto.getFilePath());
            //***修改点***，添加下面这一行代码
            userFile.setDeleteFlag(0); 
            userFile.setUserId(userId);
            ...
}
```

打开 `FiletransferController.java` 类，修改 `uploadFileSpeed` 接口如下：

```java
...
public RestResult<UploadFileVo> uploadFileSpeed(UploadFileDTO uploadFileDto, @RequestHeader("token") String token) {
            ...
            userfile.setIsDir(0);
            userfile.setUploadTime(DateUtil.getCurrentTime());
            //***修改点***，添加下面这一行代码
            userfile.setDeleteFlag(0); 
            userfileService.save(userfile);
            // fileService.increaseFilePointCount(file.getFileId());
            uploadFileVo.setSkipUpload(true);
            ...
}
```

### DTO 和 VO 实体类

在 `com.shiyanlou.file.dto` 包下创建 `DeleteFileDTO.java`实体类，作为删除文件接口参数，代码如下：

```java
package com.shiyanlou.file.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import lombok.Data;

@Data
@Schema(name = "删除文件DTO",required = true)
public class DeleteFileDTO {
    @Schema(description = "用户文件id")
    private Long userFileId;
    @Schema(description = "文件路径")
    @Deprecated
    private String filePath;
    @Schema(description = "文件名")
    @Deprecated
    private String fileName;
    @Schema(description = "是否是目录")
    @Deprecated
    private Integer isDir;
}
```

继续在该包下创建 `BatchDeleteFileDTO.java` 实体类，作为批量删除文件接口参数，代码如下：

```java
package com.shiyanlou.file.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import lombok.Data;

@Data
@Schema(name = "批量删除文件DTO",required = true)
public class BatchDeleteFileDTO {
    @Schema(description="文件集合")
    private String files;
}
```

### Service 层代码开发

打开 `com.shiyanlou.file.service` 包下的 `UserfileService.java` 类，并在该类中添加如下代码：

```java
void deleteUserFile(Long userFileId, Long sessionUserId);
List<UserFile> selectFileTreeListLikeFilePath(String filePath, long userId);
```

打开 `com.shiyanlou.file.service.impl` 包下的 `UserfileServiceImpl` 类，并在该类中添加如下代码实现：

```java
...
import java.util.UUID;
import com.shiyanlou.file.util.DateUtil;
import com.shiyanlou.file.model.File;
import com.shiyanlou.file.model.RecoveryFile;
import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;
import com.shiyanlou.file.mapper.RecoveryFileMapper;
import com.baomidou.mybatisplus.core.conditions.update.LambdaUpdateWrapper;
import com.shiyanlou.file.mapper.FileMapper;

import lombok.extern.slf4j.Slf4j;

@Slf4j
@Service
public class UserfileServiceImpl extends ServiceImpl<UserfileMapper, Userfile> implements UserfileService {
    public static Executor executor = Executors.newFixedThreadPool(20);
    @Resource
    UserfileMapper userfileMapper;
    @Resource
    FileMapper fileMapper;    
    @Resource
    RecoveryFileMapper recoveryFileMapper;
    ...

    @Override
    public void deleteUserFile(Long userFileId, Long sessionUserId) {
    
        UserFile userFile = userfileMapper.selectById(userFileId);
        String uuid = UUID.randomUUID().toString();
        if (userFile.getIsDir() == 1) {
            LambdaUpdateWrapper<UserFile> userFileLambdaUpdateWrapper = new LambdaUpdateWrapper<UserFile>();
            userFileLambdaUpdateWrapper.set(UserFile::getDeleteFlag, 1)
                    .set(UserFile::getDeleteBatchNum, uuid)
                    .set(UserFile::getDeleteTime, DateUtil.getCurrentTime())
                    .eq(UserFile::getUserFileId, userFileId);
            userfileMapper.update(null, userFileLambdaUpdateWrapper);
    
            String filePath = userFile.getFilePath() + userFile.getFileName() + "/";
            updateFileDeleteStateByFilePath(filePath, userFile.getDeleteBatchNum(), sessionUserId);
    
        }else{
    
            UserFile userFileTemp = userfileMapper.selectById(userFileId);
            File file = fileMapper.selectById(userFileTemp.getFileId());
    
            LambdaUpdateWrapper<UserFile> userFileLambdaUpdateWrapper = new LambdaUpdateWrapper<>();
            userFileLambdaUpdateWrapper.set(UserFile::getDeleteFlag, 1)
                    .set(UserFile::getDeleteTime, DateUtil.getCurrentTime())
                    .set(UserFile::getDeleteBatchNum, uuid)
                    .eq(UserFile::getUserFileId, userFileTemp.getUserFileId());
            userfileMapper.update(null, userFileLambdaUpdateWrapper);
    
        }
    
        RecoveryFile recoveryFile = new RecoveryFile();
        recoveryFile.setUserFileId(userFileId);
        recoveryFile.setDeleteTime(DateUtil.getCurrentTime());
        recoveryFile.setDeleteBatchNum(uuid);
        recoveryFileMapper.insert(recoveryFile);
    
    
    }
    
    
    @Override
    public List<UserFile> selectFileTreeListLikeFilePath(String filePath, long userId) {
        //UserFile userFile = new UserFile();
        filePath = filePath.replace("\\", "\\\\\\\\");
        filePath = filePath.replace("'", "\\'");
        filePath = filePath.replace("%", "\\%");
        filePath = filePath.replace("_", "\\_");
    
        //userFile.setFilePath(filePath);
    
        LambdaQueryWrapper<UserFile> lambdaQueryWrapper = new LambdaQueryWrapper<>();
    
        log.info("查询文件路径：" + filePath);
    
        lambdaQueryWrapper.eq(UserFile::getUserId, userId).likeRight(UserFile::getFilePath, filePath);
        return userfileMapper.selectList(lambdaQueryWrapper);
    }

}
```

在 `com.shiyanlou.file.mapper` 包下新建 `RecoveryFileMapper.java` 类，向其中写入如下代码：

```java
package com.shiyanlou.file.mapper;

import java.util.List;
import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.shiyanlou.file.model.RecoveryFile;
import com.shiyanlou.file.vo.RecoveryFileListVO;

public interface RecoveryFileMapper extends BaseMapper<RecoveryFile> {
    List<RecoveryFileListVO> selectRecoveryFileList();
}
```

在 `com.shiyanlou.file.vo` 包下新建 `RecoveryFileListVO.java` 类，向其中写入如下代码：

```java
package com.shiyanlou.file.vo;

public class RecoveryFileListVO {
    
}
```

在 `com.shiyanlou.file.service.impl` 包下新建 `RecoveryFileServiceImpl.java` 类，向其中写入如下代码：

```java
package com.shiyanlou.file.service.impl;

import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.shiyanlou.file.mapper.RecoveryFileMapper;
import com.shiyanlou.file.model.RecoveryFile;
import com.shiyanlou.file.service.RecoveryFileService;

public class RecoveryFileServiceImpl extends ServiceImpl<RecoveryFileMapper, RecoveryFile>
        implements RecoveryFileService {
    
}
```

在 `com.shiyanlou.file.service` 包下新建 `RecoveryFileService.java` 类，向其中写入如下代码：

```java
package com.shiyanlou.file.service;

import com.baomidou.mybatisplus.extension.service.IService;
import com.shiyanlou.file.model.RecoveryFile;

public interface RecoveryFileService extends IService<RecoveryFile> {
    
}
```

删除目录时需要将该文件目录下的所有文件都放入回收站，而代码实现则是通过一个删除标志来实现，为了防止文件目录下文件特别多，因此这里需要创建一个新的线程去执行，防止出现阻塞，继续向 `UserfileServiceImpl.java` 类中添加如下代码：

```java
...
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;

public class UserfileServiceImpl extends ServiceImpl<UserfileMapper, Userfile> implements UserfileService {
    ...
    private void updateFileDeleteStateByFilePath(String filePath, String deleteBatchNum, Long userId) {
        new Thread(()->{
            List<UserFile> fileList = selectFileTreeListLikeFilePath(filePath, userId);
            for (int i = 0; i < fileList.size(); i++){
                UserFile userFileTemp = fileList.get(i);
                executor.execute(new Runnable() {
                    @Override
                    public void run() {
                        //标记删除标志
                        LambdaUpdateWrapper<UserFile> userFileLambdaUpdateWrapper1 = new LambdaUpdateWrapper<>();
                        userFileLambdaUpdateWrapper1.set(UserFile::getDeleteFlag, 1)
                                .set(UserFile::getDeleteTime, DateUtil.getCurrentTime())
                                .set(UserFile::getDeleteBatchNum, deleteBatchNum)
                                .eq(UserFile::getUserFileId, userFileTemp.getUserFileId())
                                .eq(UserFile::getDeleteFlag, 0);
                        userfileMapper.update(null, userFileLambdaUpdateWrapper1);
                    }
                });

            }
        }).start();
    }
    ...
}
```

### Controller 层代码开发

打开 `com.shiyanlou.file.controller` 包，在该包下的 `FileController.java` 文件中，添加单个文件删除和批量文件删除操作接口，代码如下：

```java
...
import com.alibaba.fastjson.JSON;
import com.shiyanlou.file.dto.DeleteFileDTO;
import com.shiyanlou.file.dto.BatchDeleteFileDTO;

public class FileController {
    ...
    @Operation(summary = "删除文件", description = "可以删除文件或者目录", tags = { "file" })
    @RequestMapping(value = "/deletefile", method = RequestMethod.POST)
    @ResponseBody
    public RestResult deleteFile(@RequestBody DeleteFileDTO deleteFileDto, @RequestHeader("token") String token) {
    
        User sessionUser = userService.getUserByToken(token);
    
        userfileService.deleteUserFile(deleteFileDto.getUserFileId(), sessionUser.getUserId());
    
        return RestResult.success();
    
    }
    
    @Operation(summary = "批量删除文件", description = "批量删除文件", tags = { "file" })
    @RequestMapping(value = "/batchdeletefile", method = RequestMethod.POST)
    @ResponseBody
    public RestResult<String> deleteImageByIds(@RequestBody BatchDeleteFileDTO batchDeleteFileDto,
            @RequestHeader("token") String token) {
    
        User sessionUser = userService.getUserByToken(token);
    
        List<UserFile> userFiles = JSON.parseArray(batchDeleteFileDto.getFiles(), UserFile.class);
        for (UserFile userFile : userFiles) {
            userfileService.deleteUserFile(userFile.getUserFileId(),sessionUser.getUserId());
        }
    
        return RestResult.success().message("批量删除文件成功");
    }
}
```

到此为止删除文件接口就开发完成了，我们会发现删除文件其实就是将删除标识从 0 修改为 1，接下来我们只需要在查询文件列表的时候把标记为 1 的文件过滤掉，只查询标记为 0 的文件，就实现了删除。

打开 `resource/mybatis/mapper` 路径，在 `UserfileMapper.xml` 文件中 **修改**查询文件列表接口，（注意下面代码实在之前的基础上修改），代码如下：

```xml
    <select id="userfileList" resultType="com.shiyanlou.file.vo.UserfileListVO">
        select * from userfile a
        left join file on file.fileId = a.fileId
        <where>
            <if test="userfile.userId != null">
                and a.userId = #{userfile.userId}
            </if>
            <if test="userfile.filePath != null">
                and a.filePath = #{userfile.filePath}
            </if>
            <if test="userfile.extendName != null">
                and a.extendName = #{userfile.extendName}
            </if>
            and a.deleteFlag = 0
        </where>
        ORDER BY  isDir desc
        limit #{beginCount}, #{pageCount}
    </select>

    <sql id="selectByExtendName" >
        left join file on file.fileId = userfile.fileId
        where extendName in
        <foreach collection="fileNameList" open="(" close=")" separator="," item="fileName" >
            #{fileName}
        </foreach>
        and userId = #{userId}
        and deleteFlag = 0
    </sql>
    <sql id="selectByNotExtendName">
        left join file on file.fileId = userfile.fileId
        where extendName not in
        <foreach collection="fileNameList" open="(" close=")" separator="," item="fileName" >
            #{fileName}
        </foreach>
        and userId = #{userId}
        and deleteFlag = 0
    </sql>
```

打开 `FileController.java` 类，修改获取文件查询列表接口，查询文件数量时增加删除标记条件，只查询未删除的文件，代码如下：

```java
...
public RestResult<UserfileListVO> getUserfileList(UserfileListDTO userfileListDto,
        @RequestHeader("token") String token) {
    ...
    //***修改点***，修改下面这一行代码，在末尾进行补充
    userFileLambdaQueryWrapper.eq(UserFile::getUserId, sessionUser.getUserId())
    .eq(UserFile::getFilePath, userfileListDto.getFilePath()).eq(UserFile::getDeleteFlag, 0); 
    int total = userfileService.count(userFileLambdaQueryWrapper);

    Map<String, Object> map = new HashMap<>();
    map.put("total", total);
    map.put("list", fileList);

    return RestResult.success().data(map);

}
```

## 移动文件接口开发

在移动文件之前，需要对当前文件系统的目录结构进行显示，因此首先要做的就是展示当前目录树，代码如下：

### DTO 和 VO 实体类

在包 `com.shiyanlou.file.vo` 下创建 `TreeNodeVO.java` 类，用来展示目录结构，代码如下：

```java
package com.shiyanlou.file.vo;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import io.swagger.v3.oas.annotations.media.Schema;
import lombok.Data;


@Schema(name = "树节点VO",required = true)
@Data
public class TreeNodeVO {
  
    @Schema(description = "节点id")
    private Long id;
 
    @Schema(description = "节点名")
    private String label;
  
    @Schema(description = "深度")
    private Long depth;
   
    @Schema(description = "是否被关闭")
    private String state = "closed";

    @Schema(description = "属性集合")
    private Map<String, String> attributes = new HashMap<>();
    
    @Schema(description = "子节点列表")
    private List<TreeNodeVO> children = new ArrayList<>();

}
```

在 `com.shiyanlou.file.dto` 包下创建 `MoveFileDTO.java` 类，并初始化内容如下：

```java
@Data
@Schema(name = "移动文件DTO",required = true)
public class MoveFileDTO {

    @Schema(description = "文件路径")
    private String filePath;

    @Schema(description = "文件名")
    private String fileName;

    @Schema(description = "旧文件名")
    private String oldFilePath;
    @Schema(description = "扩展名")
    private String extendName;

}
```

继续在该包下创建 `BatchMoveFileDTO.java` 类，并初始化内容如下：

```java
@Data
@Schema(name = "批量移动文件DTO",required = true)
public class BatchMoveFileDTO {
    @Schema(description="文件集合")
    private String files;
    @Schema(description="文件路径")
    private String filePath;
}
```

### DAO 层代码开发

打开 `com.shiyanlou.file.mapper` 包，在该包下 `UserfileMapper.java` 接口中，添加如下接口，代码如下：

```java
void updateFilepathByFilepath(String oldfilePath, String newfilePath, Long userId);
```

打开 `resource/mybatis/mapper` 目录，在该目录下 `UserfileMapper.xml` 文件中，添加 MyBatis 脚本，代码如下：

```xml
<update id="updateFilepathByFilepath">
    UPDATE userfile SET filePath=REPLACE(filePath, #{param1}, #{param2})
    WHERE filePath like N'${param1}%' and userId = #{param3}
</update>
```

### Service 层代码开发

打开 `com.shiyanlou.file.service` 包下的 `UserfileService.java` 类，并在该类中添加如下代码：

```java
List<UserFile> selectFilePathTreeByUserId(Long userId);
void updateFilepathByFilepath(String oldfilePath, String newfilePath, String fileName, String extendName, Long userId);
```

打开 `com.shiyanlou.file.service.impl` 包下的 `UserfileServiceImpl.java` 类，并在该类中添加如下代码：

```java
...
import org.apache.commons.lang3.StringUtils;

public class UserfileServiceImpl extends ServiceImpl<UserfileMapper, UserFile> implements UserfileService {
    ...
    @Override
    public void updateFilepathByFilepath(String oldfilePath, String newfilePath, String fileName, String extendName, Long userId) {
        if ("null".equals(extendName)){
            extendName = null;
        }
    
        LambdaUpdateWrapper<UserFile> lambdaUpdateWrapper = new LambdaUpdateWrapper<UserFile>();
        lambdaUpdateWrapper.set(UserFile::getFilePath, newfilePath)
        .eq(UserFile::getFilePath, oldfilePath)
        .eq(UserFile::getFileName, fileName)
        .eq(UserFile::getUserId, userId);
        if (StringUtils.isNotEmpty(extendName)) {
            lambdaUpdateWrapper.eq(UserFile::getExtendName, extendName);
        } else {
            lambdaUpdateWrapper.isNull(UserFile::getExtendName);
        }
        userfileMapper.update(null, lambdaUpdateWrapper);
        //移动子目录
        oldfilePath = oldfilePath + fileName + "/";
        newfilePath = newfilePath + fileName + "/";
    
        oldfilePath = oldfilePath.replace("\\", "\\\\\\\\");
        oldfilePath = oldfilePath.replace("'", "\\'");
        oldfilePath = oldfilePath.replace("%", "\\%");
        oldfilePath = oldfilePath.replace("_", "\\_");
    
        if (extendName == null) { //为null说明是目录，则需要移动子目录
            userfileMapper.updateFilepathByFilepath(oldfilePath, newfilePath, userId);
        }
    }

    ...

    @Override
    public List<UserFile> selectFilePathTreeByUserId(Long userId) { LambdaQueryWrapper<UserFile> lambdaQueryWrapper = new LambdaQueryWrapper<>();
        lambdaQueryWrapper.eq(UserFile::getUserId, userId)
                .eq(UserFile::getIsDir, 1);
        return userfileMapper.selectList(lambdaQueryWrapper);
    }

    ...
}
```

### Controller 层代码开发

打开 `com.shiyanlou.file.controller` 包，在该包下的 `FileController.java` 文件中，添加获取文件树接口，代码如下：

```java
import com.shiyanlou.file.vo.TreeNodeVO;
import java.util.Queue;
import java.util.LinkedList;

public class FileController {

    ...
    @Operation(summary = "获取文件树", description = "文件移动的时候需要用到该接口，用来展示目录树", tags = {"file"})
    @RequestMapping(value = "/getfiletree", method = RequestMethod.GET)
    @ResponseBody
    public RestResult<TreeNodeVO> getFileTree(@RequestHeader("token") String token){
        RestResult<TreeNodeVO> result = new RestResult<TreeNodeVO>();
        UserFile userFile = new UserFile();
        User sessionUser = userService.getUserByToken(token);
        userFile.setUserId(sessionUser.getUserId());

        List<UserFile> filePathList = userfileService.selectFilePathTreeByUserId(sessionUser.getUserId());
        TreeNodeVO resultTreeNode = new TreeNodeVO();
        resultTreeNode.setLabel("/");

        for (int i = 0; i < filePathList.size(); i++){
            String filePath = filePathList.get(i).getFilePath() + filePathList.get(i).getFileName() + "/";

            Queue<String> queue = new LinkedList<>();

            String[] strArr = filePath.split("/");
            for (int j = 0; j < strArr.length; j++){
                if (!"".equals(strArr[j]) && strArr[j] != null){
                    queue.add(strArr[j]);
                }

            }
            if (queue.size() == 0){
                continue;
            }
            resultTreeNode = insertTreeNode(resultTreeNode,"/", queue);


        }
        result.setSuccess(true);
        result.setData(resultTreeNode);
        return result;

    }
    ...
}
```

上面这段代码需要另外调用一段递归代码，这段代码逻辑主要是将查询出来的文件路径组装成树形结构，代码如下：

```java
public TreeNodeVO insertTreeNode(TreeNodeVO treeNode, String filePath, Queue<String> nodeNameQueue){

    List<TreeNodeVO> childrenTreeNodes = treeNode.getChildren();
    String currentNodeName = nodeNameQueue.peek();
    if (currentNodeName == null){
        return treeNode;
    }

    Map<String, String> map = new HashMap<>();
    filePath = filePath + currentNodeName + "/";
    map.put("filePath", filePath);

    if (!isExistPath(childrenTreeNodes, currentNodeName)){  //1、判断有没有该子节点，如果没有则插入
        //插入
        TreeNodeVO resultTreeNode = new TreeNodeVO();


        resultTreeNode.setAttributes(map);
        resultTreeNode.setLabel(nodeNameQueue.poll());
        // resultTreeNode.setId(treeid++);

        childrenTreeNodes.add(resultTreeNode);

    }else{  //2、如果有，则跳过
        nodeNameQueue.poll();
    }

    if (nodeNameQueue.size() != 0) {
        for (int i = 0; i < childrenTreeNodes.size(); i++) {

            TreeNodeVO childrenTreeNode = childrenTreeNodes.get(i);
            if (currentNodeName.equals(childrenTreeNode.getLabel())){
                childrenTreeNode = insertTreeNode(childrenTreeNode, filePath, nodeNameQueue);
                childrenTreeNodes.remove(i);
                childrenTreeNodes.add(childrenTreeNode);
                treeNode.setChildren(childrenTreeNodes);
            }

        }
    }else{
        treeNode.setChildren(childrenTreeNodes);
    }

    return treeNode;

}

public boolean isExistPath(List<TreeNodeVO> childrenTreeNodes, String path){
    boolean isExistPath = false;

    try {
        for (int i = 0; i < childrenTreeNodes.size(); i++){
            if (path.equals(childrenTreeNodes.get(i).getLabel())){
                isExistPath = true;
            }
        }
    }catch (Exception e){
        e.printStackTrace();
    }


    return isExistPath;
}
```

上面已经可以将目录树展示出来了，接下来完成最后真正的移动文件接口，移动文件接口的本质其实就是将保存到数据库中的虚拟路径做一个修改即可，真实的保存在磁盘上的文件是不需要做任何变动的，代码如下：

```java
...
import com.shiyanlou.file.dto.MoveFileDTO;
import com.shiyanlou.file.dto.BatchMoveFileDTO;

public class FileController {
    ...
    @Operation(summary = "文件移动", description = "可以移动文件或者目录", tags = { "file" })
    @RequestMapping(value = "/movefile", method = RequestMethod.POST)
    @ResponseBody
    public RestResult<String> moveFile(@RequestBody MoveFileDTO moveFileDto, @RequestHeader("token") String token) {
        User sessionUser = userService.getUserByToken(token);
        String oldfilePath = moveFileDto.getOldFilePath();
        String newfilePath = moveFileDto.getFilePath();
        String fileName = moveFileDto.getFileName();
        String extendName = moveFileDto.getExtendName();
    
        userfileService.updateFilepathByFilepath(oldfilePath, newfilePath, fileName, extendName, sessionUser.getUserId());
        return RestResult.success();
    
    }
    
    @Operation(summary = "批量移动文件", description = "可以同时选择移动多个文件或者目录", tags = { "file" })
    @RequestMapping(value = "/batchmovefile", method = RequestMethod.POST)
    @ResponseBody
    public RestResult<String> batchMoveFile(@RequestBody BatchMoveFileDTO batchMoveFileDto,
            @RequestHeader("token") String token) {
    
        User sessionUser = userService.getUserByToken(token);
        String files = batchMoveFileDto.getFiles();
        String newfilePath = batchMoveFileDto.getFilePath();
        List<UserFile> userFiles = JSON.parseArray(files, UserFile.class);
    
        for (UserFile userFile : userFiles) {
            userfileService.updateFilepathByFilepath(userFile.getFilePath(), newfilePath, userFile.getFileName(),
                    userFile.getExtendName(), sessionUser.getUserId());
        }
    
        return RestResult.success().data("批量移动文件成功");
    
    }
    ...
}
```

## 文件重命名接口开发

### DTO 和 VO 实体类开发

在包 `com.shiyanlou.file.dto` 下创建 `RenameFileDTO.java` 类，用来接受重命名接口传参，代码如下：

```java
package com.shiyanlou.file.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import lombok.Data;

@Data
@Schema(name = "重命名文件DTO",required = true)
public class RenameFileDTO {
    private Long userFileId;

    @Schema(description = "文件名")
    private String fileName;
   
}
```

### DAO 层代码开发

打开 `com.shiyanlou.file.mapper` 包，在该包下 `UserfileMapper.java` 接口中，添加如下接口，代码如下：

```java
import org.apache.ibatis.annotations.Param;
public interface UserfileMapper extends BaseMapper<UserFile> {
    ...
    void replaceFilePath(@Param("filePath") String filePath, @Param("oldFilePath") String oldFilePath, @Param("userId") Long userId);
    Long selectStorageSizeByUserId(Long userId);
}
```

打开 `resource/mybatis/mapper` 目录，在该目录下 `UserfileMapper.xml` 文件中，添加 MyBatis 脚本，代码如下：

```xml
<update id="replaceFilePath">
    UPDATE userfile SET filepath=REPLACE(filepath, #{oldFilePath}, #{filePath})
    WHERE filepath LIKE N'${oldFilePath}%' and userId = #{userId};
</update>
```

### Service 层代码开发

打开 `com.shiyanlou.file.service` 包下的 `UserfileService.java` 类，并在该类中添加如下代码：

```java
List<UserFile> selectUserFileByNameAndPath(String fileName, String filePath, Long userId);
void replaceUserFilePath(String filePath, String oldFilePath, Long userId);
```

打开 `com.shiyanlou.file.service.impl` 包下的 `UserfileServiceImpl` 类，并在该类中添加如下代码实现：

```java
    @Override
    public List<UserFile> selectUserFileByNameAndPath(String fileName, String filePath, Long userId) {
        LambdaQueryWrapper<UserFile> lambdaQueryWrapper = new LambdaQueryWrapper<>();
        lambdaQueryWrapper.eq(UserFile::getFileName, fileName)
                .eq(UserFile::getFilePath, filePath)
                .eq(UserFile::getUserId, userId)
                .eq(UserFile::getDeleteFlag, "0");
        return userfileMapper.selectList(lambdaQueryWrapper);
    }

    @Override
    public void replaceUserFilePath(String filePath, String oldFilePath, Long userId) {
        userfileMapper.replaceFilePath(filePath, oldFilePath, userId);
    }
```

### Controller 层代码开发

打开 `com.shiyanlou.file.controller` 包，在该包下的 `FileController.java` 文件中，添加文件重命名接口，代码如下：

```java
import com.shiyanlou.file.dto.RenameFileDTO;
import com.baomidou.mybatisplus.core.conditions.update.LambdaUpdateWrapper;
import com.shiyanlou.file.model.File;

public class FileController {
    ...
    @Operation(summary = "文件重命名", description = "文件重命名", tags = {"file"})
    @RequestMapping(value = "/renamefile", method = RequestMethod.POST)
    @ResponseBody
    public RestResult<String> renameFile(@RequestBody RenameFileDTO renameFileDto, @RequestHeader("token") String token) {
        User sessionUser = userService.getUserByToken(token);
        UserFile userFile = userfileService.getById(renameFileDto.getUserFileId());
    
        List<UserFile> userFiles = userfileService.selectUserFileByNameAndPath(renameFileDto.getFileName(), userFile.getFilePath(), sessionUser.getUserId());
        if (userFiles != null && !userFiles.isEmpty()) {
            return RestResult.fail().message("同名文件已存在");
    
        }
        if (1 == userFile.getIsDir()) {
            LambdaUpdateWrapper<UserFile> lambdaUpdateWrapper = new LambdaUpdateWrapper<>();
            lambdaUpdateWrapper.set(UserFile::getFileName, renameFileDto.getFileName())
                    .set(UserFile::getUploadTime, DateUtil.getCurrentTime())
                    .eq(UserFile::getUserFileId, renameFileDto.getUserFileId());
            userfileService.update(lambdaUpdateWrapper);
            userfileService.replaceUserFilePath(userFile.getFilePath() + renameFileDto.getFileName() + "/",
                    userFile.getFilePath() + userFile.getFileName() + "/", sessionUser.getUserId());
        } else {
            File file = fileService.getById(userFile.getFileId());
    
            LambdaUpdateWrapper<UserFile> lambdaUpdateWrapper = new LambdaUpdateWrapper<>();
            lambdaUpdateWrapper.set(UserFile::getFileName, renameFileDto.getFileName())
                    .set(UserFile::getUploadTime, DateUtil.getCurrentTime())
                    .eq(UserFile::getUserFileId, renameFileDto.getUserFileId());
            userfileService.update(lambdaUpdateWrapper);
    
    
        }
    
        return RestResult.success();
    }
    ...
}
```

## 获取存储信息接口

### Dao 层代码开发

打开 `com.shiyanlou.file.mapper` 包，在该包下 `UserfileMapper.java` 接口中，添加如下接口，代码如下：

```java
Long selectStorageSizeByUserId(@Param("userId") Long userId);
```

打开 `resource/mybatis/mapper` 目录，在该目录下 `UserfileMapper.xml` 文件中，添加 MyBatis 脚本，代码如下：

```xml
<select id="selectStorageSizeByUserId" resultType="java.lang.Long" parameterType="java.lang.Long">
    SELECT SUM(fileSize) FROM userfile
    LEFT JOIN file ON file.fileId = userfile.fileId
    WHERE userfile.userId = #{userId} and deleteFlag = 0
</select>
```

### Service 层代码开发

打开 `com.shiyanlou.file.service` 包下的 `FiletransferService.java` 类，并在该类中添加如下代码：

```java
Long selectStorageSizeByUserId(Long userId);
```

打开 `com.shiyanlou.file.service.impl` 包下的 `FiletransferServiceImpl.java` 类，并在该类中添加如下代码：

```java
@Override
public Long selectStorageSizeByUserId(Long userId) {
    return userfileMapper.selectStorageSizeByUserId(userId);
}
```

### Controller 层代码开发

打开 `com.shiyanlou.file.controller` 包，并在 `FiletransferController.java` 接口中添加如下代码：

```java
...
import com.shiyanlou.file.model.Storage;

public class FiletransferController {
    ...
    @Operation(summary = "获取存储信息", description = "获取存储信息", tags = {"filetransfer"})
    @RequestMapping(value = "/getstorage", method = RequestMethod.GET)
    @ResponseBody
    public RestResult<Long> getStorage(@RequestHeader("token") String token) {

        User sessionUserBean = userService.getUserByToken(token);
        Storage storageBean = new Storage();


        Long storageSize = filetransferService.selectStorageSizeByUserId(sessionUserBean.getUserId());
        return RestResult.success().data(storageSize);

    }
}
```

打开 `com.shiyanlou.file.model` 包，新建 `Storage.java` 文件，并向其中写入如下代码：

```java
package com.shiyanlou.file.model;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.Table;

import com.baomidou.mybatisplus.annotation.IdType;
import com.baomidou.mybatisplus.annotation.TableId;
import com.baomidou.mybatisplus.annotation.TableName;

import lombok.Data;

@Data
@Table(name = "storage")
@Entity
@TableName("storage")
public class Storage {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @TableId(type = IdType.AUTO)
    @Column(columnDefinition="bigint(20)")
    private Long storageId;

    @Column(columnDefinition="bigint(20)")
    private Long userId;

    @Column(columnDefinition="bigint(20)")
    private Long storageSize;

}
```


## 实验总结

本节实验带领大家完成了文件移动，删除，重命名接口的开发，到此为止整个文件管理的最基本的功能就已经开发完成了，但是这仅仅只是基础，后面可以根据自己的需要，自行设计及开发。

需要注意的是，目前的删除文件只是实现了文件的逻辑删除，并没有真正的从服务器删除掉，真正删除文件的操作可以在回收站中去删除，关于回收站的功能大家可以自行进行完善。

后台的课程到这里就结束了，相信大家已经掌握了一定的开发和设计能力，如果你有更多的想法，可以对该网盘继续进行开发。

本次实验完整代码可以通过如下命令进行下载：

```bash
wget https://labfile.oss.aliyuncs.com/courses/8842/code9.zip
```
