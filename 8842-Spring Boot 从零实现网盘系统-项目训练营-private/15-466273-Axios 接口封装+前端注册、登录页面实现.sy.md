---
show: step
version: 1.0
enable_checker: true
---

# Axios 接口封装+前端注册、登录页面实现

## 实验介绍

本实验将介绍采用 Axios 封装接口，并添加注册、登录页面及相关接口。

#### 知识点

- Axios 封装 GET、POST、PUT、DELETE 类型接口
- Element UI 的 Form 表单组件使用

#### 开发计划

- 开发内容：完成注册、登录页面的开发，添加页面元素；采用 Axios 封装 GET、POST、PUT、DELETE 类型的接口，添加登录、注册接口，介绍其引入和使用方法，并简单介绍采用 Vuex 在各个组件间共享登录状态。
- 开发耗时：实验预计完成时间为 1~2 小时
- 开发难点：
  1. Axios 封装各个类型的接口，如何添加、引入和使用接口
  2. 使用 Form 表单组件完成注册、登录页面

## Axios 安装和接口封装

Axios（[axios 中文网|axios API 中文文档 | axios](http://www.axios-js.com/)）是易用、简洁且高效的 http 库， 使用 Promise 管理异步，支持请求和响应拦截器，自动转换 JSON 数据等高级配置，与 Vue.js 有很好的融合。

终端中键入以下命令，以安装 Axios：

```bash
npm install axios
```

为了便于后续接口管理，一般都将所有的接口单独放在同一目录下统一管理。在 `src` 下新建文件夹`request`，并创建文件 `src/request/http.js`，后续对接口的 baseURL、超时时间、请求和响应拦截、接口类型封装等都将在此文件中。

### Axios 基础设置

在 `http.js` 中先来引入 Axios，设置请求超时时间，基础 URL，并自定义 POST 请求头：

```javascript
import axios from 'axios'

// 请求超时时间
axios.defaults.timeout = 10000 * 5
// 请求基础URL，对应后台服务接口地址
axios.defaults.baseURL = 'http://localhost:8081'
// 自定义post请求头
axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded'
```

设置请求拦截器和响应拦截器，对接口的请求头、响应结果做统一处理，例如自定义请求头，对接口响应的 HTTP 状态码非 200 的情况做处理等：

```javascript
import { Message } from 'element-ui'

// 请求拦截器
axios.interceptors.request.use(
  (config) => {
    //	自定义请求头
    return config
  },
  (error) => {
    //	请求错误时
    console.log(error) //	打印错误信息
    return Promise.reject(error)
  }
)

// 响应拦截器
axios.interceptors.response.use(
  (response) => {
    if (response.status === 200) {
      //	接口HTTP状态码为200时
      return Promise.resolve(response)
    }
  },
  // HTTP状态码非200的情况
  (error) => {
    if (error.response.status) {
      switch (error.response.status) {
        case 500: //	HTTP状态码500
          Message.error('后台服务发生错误')
          break
        case 401: //	HTTP状态码401
          Message.error('无权限')
          break
        case 404: //	HTTP状态码404
          Message.error('当前接口不存在')
          break
        default:
          this.$message.error(error.response.message) //	页面显示接口返回的错误信息
          return Promise.reject(error.response)
      }
    }
  }
)
```

### GET、POST、PUT、DELETE 接口类型封装

get 请求中的参数分为 params 和 info，其中 params 是查询参数，接口中的表现形式为 & 符号连接的 key=value 形式的字符串，统一用?符号拼接在接口后，例如常用的分页查询接口 `getFileList?page=1&pageSize=10`；info 参数直接拼接在 url 中，例如某些查询接口 get 请求，需要把 id 拼接在 url 中。

```javascript
/**
 * get方法，对应get请求
 */
export function get(url, params, info = '') {
  return new Promise((resolve, reject) => {
    axios
      .get(url + info, {
        params: params
      })
      .then((res) => {
        resolve(res.data) //	返回接口响应结果
      })
      .catch((err) => {
        reject(err.data)
      })
  })
}
```

post 请求中的参数分为 formData 格式和 json 格式，需要根据后台接口采用不同的传参格式：

```javascript
/**
 * post方法，对应post请求
 * info为 true，formData格式；
 * info为 undefined或false，是json格式
 */
export function post(url, data = {}, info) {
  return new Promise((resolve, reject) => {
    let newData = data
    if (info) {
      //  转formData格式
      newData = new FormData()
      for (let i in data) {
        newData.append(i, data[i])
      }
    }
    axios
      .post(url, newData)
      .then((res) => {
        resolve(res.data)
      })
      .catch((err) => {
        reject(err.data)
      })
  })
}
```

put 请求和 delete 请求封装同理：

```javascript
/**
 * 封装put请求
 */

export function put(url, params = {}, info = '') {
  return new Promise((resolve, reject) => {
    axios.put(url + info, params).then(
      (res) => {
        resolve(res.data)
      },
      (err) => {
        reject(err.data)
      }
    )
  })
}

/**
 * 封装delete请求
 */
export function axiosDelete(url, params = {}, info = '') {
  return new Promise((resolve, reject) => {
    axios
      .delete(url + info, {
        params: params
      })
      .then((res) => {
        resolve(res.data)
      })
      .catch((err) => {
        reject(err.data)
      })
  })
}
```

### 注册、登录接口封装

在 `src/request` 下创建新文件 `user.js`，所有与用户相关的接口均维护在这个文件中。

首先引入封装好的 get、post 类型的请求：

```javascript
import { get, post } from './http'
```

接下来封装登录接口：

- export 表示导出此接口，以便后续在 vue 文件中引入此接口去调用；
- const login 表示定义当前接口名称为 login，p 表示接口传参，对应刚才封装 get 类型请求时的 params，如果还需要传参 info，传参应当为(p, info)；
- get 表示接口类型为 get，`'/user/login'`为后台提供的接口 path。

```javascript
// 登录接口
export const login = (p) => get('/user/login', p)
```

封装注册接口：

```javascript
// 注册接口
export const addUser = (p) => post('/user/register', p)
```

## 后台项目启动

后台项目的编写可以参考本次课程的后台项目相关的实验，这里仅仅介绍后台项目启动，和如何连接后台接口。

在 `qiwen-file/src/main/resources/application.properties` 中第 1 行添加 `server.port=8081` 来修改后台服务启动端口：

```properties
server.port=8081
spring.datasource.url=jdbc:mysql://localhost:3306/file?serverTimezone=GMT%2B8&useUnicode=true&characterEncoding=utf-8&allowMultiQueries=true
...
```

新建终端启动项目：

```bash
sudo service mysql start
cd /home/project/qiwen-file
mvn spring-boot:run
```

当出现以下结果，说明后台项目启动成功：

![12-1](https://doc.shiyanlou.com/courses/3472/1557563/b7fd02ff5506f52596327dcfe5da77a6-0/wm)

### 接口连接

我们需要对 Axios 中的设置和封装做些改动，以便在本地开发环境中也可以调用接口。

在 `public` 中新建 `config.json` 文件，存放后台接口，这里必须配置完整的接口 baseURL，包括协议、IP、端口，有时候后台会有后缀 `/backend` 等：

```json
{
  "baseUrl": "http://localhost:8081"
}
```

在 `vue.config.js` 中配置代理：

```javascript
const productConfig = require('./public/config.json') // 引入config.json文件
module.exports = {
  publicPath: '/',
  devServer: {
    host: '0.0.0.0',
    open: true,
    disableHostCheck: true,
    proxy: {
      //配置代理，解决跨域请求后台数据的问题
      '/api': {
        target: productConfig.baseUrl, //后台接口，连接本地服务
        ws: true, //是否跨域
        changeOrigin: true,
        pathRewrite: {
          '^/api': '/'
        }
      }
    }
  }
}
```

对 `src/request/http.js` 中的 Axios 的 baseURL 做修改：

```javascript
// 请求基础URL
axios.defaults.baseURL = '/api'
```

现在我们重新启动项目。

## 注册页面编写

先来采用 Element UI 的表单 Form 组件等编写页面，在 `src/views/Register.vue` 中键入以下内容：

```vue
<template>
  <div class="registerWrapper" id="registerBackground">
    <div class="formWrapper">
      <h1 class="registerTitle">注册</h1>
      <el-form
        :model="ruleForm"
        :rules="rules"
        ref="ruleForm"
        label-width="100px"
        class="demo-ruleForm"
        hide-required-asterisk
      >
        <el-form-item prop="username">
          <el-input
            prefix-icon="el-icon-user"
            v-model="ruleForm.username"
            placeholder="用户名"
          ></el-input>
        </el-form-item>
        <el-form-item prop="telephone">
          <el-input
            prefix-icon="el-icon-mobile-phone"
            v-model="ruleForm.telephone"
            placeholder="手机号"
          ></el-input>
        </el-form-item>
        <el-form-item prop="password">
          <el-input
            prefix-icon="el-icon-lock"
            v-model="ruleForm.password"
            placeholder="密码"
            show-password
          ></el-input>
        </el-form-item>
        <el-form-item class="registerButtonWrapper">
          <el-button
            class="registerButton"
            type="primary"
            @click="submitForm('ruleForm')"
            >注册</el-button
          >
        </el-form-item>
      </el-form>
    </div>
  </div>
</template>

<script>
export default {
  name: "Register",
  data() {
    return {
      ruleForm: {
        username: '',
        telephone: '',
        password: '',
      },
      rules: {
        username: [
          { required: true, message: "请输入用户名", trigger: "blur" },
        ],
        password: [
          { required: true, message: "请输入密码", trigger: "blur" },
          {
            min: 5,
            max: 20,
            message: "长度在 5 到 20 个字符",
            trigger: "blur",
          },
        ],
        telephone: [
          { required: true, message: "请输入手机号", trigger: "blur" },
          { min: 11, max: 11, message: "请输入11位手机号", trigger: "blur" },
        ],
      },
    };
  },
  methods: {
    //  注册按钮-点击事件
    submitForm() {},
  },
};
</script>

<style lang="stylus" scoped>
.registerWrapper {
  height: 500px !important;
  min-height: 500px !important;
  width: 100% !important;
  padding-top: 50px;

  .formWrapper {
    width: 375px;
    margin: 0 auto;
    text-align: center;

    .registerTitle {
      margin-bottom: 10px;
      font-weight: 300;
      font-size: 30px;
      color: #000;
    }

    .demo-ruleForm {
      width: 100%;
      margin-top: 20px;

      >>> .el-form-item__content {
        margin-left: 0 !important;
      }

      &>>> .el-input__inner {
        font-size: 16px;
      }

      .registerButtonWrapper {
        .registerButton {
          width: 100%;
        }

        &>>> .el-button {
          padding: 10px 90px;
          font-size: 16px;
        }
      }
    }

    .tip {
      width: 70%;
      margin-left: 86px;
    }
  }
}
</style>
```

看下页面效果：

<img src="https://doc.shiyanlou.com/courses/3472/1557563/1d4ff9263d586a351348da2ed96ad03d-0/wm" alt="图片描述" style="zoom:67%;" />

### 注册接口使用

继续编辑 `Register.vue` 文件，引入封装好的注册接口：

```javascript
import { addUser } from '@/request/user.js'
```

在注册按钮的点击事件中调用注册接口：

```vue
<script>
import { addUser } from '@/request/user.js' //	引入注册接口

export default {
  name: 'Register',
  data() {
    return {
      // ……
    }
  },
  methods: {
    //  注册按钮-点击事件
    submitForm(formName) {
      this.$refs[formName].validate((valid) => {
        //	校验表单
        if (valid) {
          //  各项校验通过-调用注册接口，传参用户名、手机号和密码
          addUser(this.ruleForm).then((res) => {
            if (res.success) {
              this.$notify({
                title: '成功',
                message: '注册成功！已跳转到登录页面',
                type: 'success'
              })
              this.$refs[formName].resetFields() // 注册成功之后清空表单
              this.$router.replace({ path: '/login' }) // 注册成功之后跳转到登录页面
            } else {
              this.$message.error(res.message) //  显示接口返回的错误信息
            }
          })
        } else {
          // 表单校验没通过
          this.$message.error('请完善信息！')
          return false
        }
      })
    }
  }
}
</script>
```

来看下接口调用是否符合代码中的处理：

![12-3](https://doc.shiyanlou.com/courses/3472/1557563/8b90bda3fec2cf8fd95f99a494e50580-0/wm)

注册接口返回值中的 success 为 true 时：

<img src="https://doc.shiyanlou.com/courses/3472/1557563/be2988673e8e8fbfcee75523feb99a34-0/wm" alt="12-4" style="zoom: 67%;" />

注册接口的返回值中 success 为 false 时：

![12-5](https://doc.shiyanlou.com/courses/3472/1557563/ba62fe303251968011c72a15effb9888-0/wm)

## 登录页面编写

在 `src/views/Login.vue` 中编写登录页面：

```vue
<template>
  <div class="loginWrapper" id="loginBackground">
    <div class="formWrapper">
      <h1 class="loginTitle">登录</h1>
      <el-form
        :model="ruleForm"
        :rules="rules"
        ref="ruleForm"
        label-width="100px"
        class="demo-ruleForm"
        hide-required-asterisk
      >
        <el-form-item prop="telephone">
          <el-input
            prefix-icon="el-icon-mobile-phone"
            v-model="ruleForm.telephone"
            placeholder="手机号"
          ></el-input>
        </el-form-item>
        <el-form-item prop="password">
          <el-input
            prefix-icon="el-icon-lock"
            v-model="ruleForm.password"
            placeholder="密码"
            show-password
          ></el-input>
        </el-form-item>
        <el-form-item class="loginButtonWrapper">
          <el-button
            class="loginButton"
            type="primary"
            @click="submitForm('ruleForm')"
          >
            登录
          </el-button>
        </el-form-item>
      </el-form>
    </div>
  </div>
</template>

<script>
export default {
  name: 'Login',
  data() {
    return {
      ruleForm: {
        telephone: '',
        password: ''
      },
      rules: {
        telephone: [{ required: true, message: '请输入手机号', trigger: 'blur' }],
        password: [
          { required: true, message: '请输入密码', trigger: 'blur' },
          { min: 5, max: 20, message: '长度在 5 到 20 个字符', trigger: 'blur' }
        ]
      }
    }
  },
  methods: {
    //  登录按钮-点击事件
    submitForm() {}
  }
}
</script>

<style lang="stylus" scoped>
.loginWrapper {
  height: 550px !important;
  min-height: 550px !important;
  padding-top: 50px;

  .formWrapper {
    width: 375px;
    margin: 0 auto;
    text-align: center;

    .loginTitle {
      margin-bottom: 10px;
      font-weight: 300;
      font-size: 30px;
      color: #000;
    }

    .demo-ruleForm {
      width: 100%;
      margin-top: 20px;

      >>> .el-form-item__content {
        margin-left: 0 !important;
      }

      &>>> .el-input__inner {
        font-size: 16px;
      }

      .forgetPassword {
        text-align: right;
        margin: -22px 0 0 0;
      }

      .loginButtonWrapper {
        .loginButton {
          width: 100%;
        }

        &>>> .el-button {
          padding: 10px 90px;
          font-size: 16px;
        }
      }
    }

    .tip {
      width: 70%;
      margin-left: 86px;
    }
  }
}
</style>
```

### 登录接口使用

在登录按钮的点击事件中调用登录接口，这里我们需要在登录之后在接口的自定义请求头中添加 token。

键入以下命令安装 `js-cookie`：

```bash
npm install js-cookie
```

在 `src/request/http.js` 和 `src/views/Login.vue` 中引入 `js-cookie`，并自定义请求头：

`http.js` 中使用 `js-cookie`：

```javascript
import Cookies from 'js-cookie'

// 请求拦截器
axios.interceptors.request.use(
  (config) => {
    //	自定义请求头
    config.headers['token'] = Cookies.get('token')
    return config
  },
  (error) => {
    console.log(error)
    return Promise.reject(error)
  }
)
```

登录页面使用 `js-cookie`，引入封装好的登录接口，编辑 `src/views/Login.vue` 文件：

```vue
...
<script>
import { login } from '@/request/user.js'	//	引入登录接口
import Cookies from 'js-cookie'

export default {
  name: 'Login',
  data() {
    return {
      // ......
    }
  },
  methods: {
    //  登录按钮-点击事件
    submitForm(formName) {
      this.$refs[formName].validate((valid) => {
        if (valid) {
          // 各项校验通过-调用登录接口
          login(this.ruleForm, true).then((res) => {
            if (res.success) {
              Cookies.set('token', res.data.token) //	在cookies中添加token
              this.$message.success('登录成功！')
              this.$refs[formName].resetFields() //	清空表单项
              this.$router.replace({ name: 'Home' }) // 跳转到首页
            } else {
              this.$message.error('手机号或密码错误！')
            }
          })
        } else {
          this.$message.error('请完善信息！')
          return false
        }
      })
    }
  }
}
</script>
```

使用刚才注册的用户，来测试下登录接口：

![12-6](https://doc.shiyanlou.com/courses/3472/1557563/006e7e0c3cee644eada6bbabb5198014-0/wm)

![12-7](https://doc.shiyanlou.com/courses/3472/1557563/8b524482dcbedf8cb1dee61d2d2f75e2-0/wm)

## 登录状态共享和页面跳转

在登录之后，需要保存登录状态，之后自动跳转到首页。若用户直接进入了首页，就需要自动跳转到登录页面，若用户已登录，进入登录和注册页面时，就需要自动跳转到首页。那么需要把登录状态共享给各个页面，就需要用到 Vue Router 的全局前置守卫（[导航守卫 | Vue Router](https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E5%85%A8%E5%B1%80%E5%89%8D%E7%BD%AE%E5%AE%88%E5%8D%AB)）和 Vuex，关于 Vuex 的知识将会在下个实验介绍，这次实验先来实现状态共享和界面自动跳转。

### 登录状态保存

在 `src/request/user.js` 中添加获取用户登录信息接口：

```javascript
// 获取登录状态及用户信息
export const checkUserLoginInfo = (p) => get('/user/checkuserlogininfo', p)
```

先来使用 Vuex 把状态保存实现，在 `src/store` 下新建文件夹 `module`，并新建文件 `src/store/module/user.js`，键入以下内容（下节实验会介绍 Vuex 的使用）：

```javascript
import { checkUserLoginInfo } from '@/request/user.js' // 引入获取用户登录信息接口

export default {
  state: {
    isLogin: false, // 初始时候给一个 isLogin = false 表示用户未登录
    username: '',
    userId: 0,
    userImgUrl: '',
    userInfoObj: {}
  },
  mutations: {
    changeLogin(state, data) {
      state.isLogin = data
    },
    changeUsername(state, data) {
      state.username = data
    },
    changeUserId(state, data) {
      state.userId = data
    },
    changeUserInfoObj(state, data) {
      state.userInfoObj = Object.assign({}, state.userInfoObj, data)
    }
  },
  actions: {
    getUserInfo(context) {
      return checkUserLoginInfo().then((res) => {
        if (res.success) {
          context.commit('changeLogin', res.success)
          context.commit('changeUsername', res.data.username)
          context.commit('changeUserId', res.data.userId)
          context.commit('changeUserInfoObj', res.data)
        } else {
          context.commit('changeLogin', res.success)
        }
      })
    }
  }
}
```

在 `src/store/index.js` 中引入刚才创建好的 `user.js`，并将相关数据导出：

```javascript
import Vue from 'vue'
import Vuex from 'vuex'

import user from './module/user' // 引入user.js

Vue.use(Vuex)

export default new Vuex.Store({
  state: {
    //
  },
  getters: {
    isLogin: (state) => state.user.isLogin,
    username: (state) => state.user.username,
    userId: (state) => state.user.userId,
    userInfoObj: (state) => state.user.userInfoObj
  },
  mutations: {
    //
  },
  actions: {
    //
  },
  modules: {
    user
  }
})
```

之后就可以在 `*.vue` 文件中使用 `this.$store.getters.isLogin` 来获取用户的登录状态了。

### 全局前置守卫

为了判断哪些路由需要登录之后才可进入，需要在路由上添加一些信息。在 `src/router/index.js` 中给首页路由添加 meta 属性，并添加参数 `requireAuth`，值为 true：

```javascript
{
    path: '/',  //  路由路径，即浏览器地址栏中显示的URL
    name: 'Home', //  路由名称
    component: Home, //  路由所使用的页面
    meta: {
      requireAuth: true
    }
}
```

在 `src/router` 下新建文件 `before.js`，引入 Vue Router 和状态保存文件 `src/store/index.js`：

```javascript
import router from './index.js'
import store from '@/store/index.js'

// 路由全局前置守卫
router.beforeEach((to, from, next) => {
  // 调用接口，判断当前登录状态
  store.dispatch("getUserInfo").then(() => {
    if (to.matched.some(m => m.meta.requireAuth)) {
      if (!store.getters.isLogin) { // 没有登录    
        next({
          path: '/login',
          query: { Rurl: to.fullPath }
        })
      } else {
        next()   // 正常跳转到你设置好的页面 
      }
    } else {
      next()  // 正常跳转到你设置好的页面 
    }
  })
})
```

添加全局前置守卫，可以在触发导航之前进行一些处理，当处理完成后才会执行导航：

1. 先调用接口，判断当前登录状态。
2. 判断将要去的路由是否需要登录，即刚才我们给路由添加的参数 `meta.requireAuth` 是否为 true，若为 true，表示需要登录后才可进入；若没有设置当前参数，或参数值为 false，表示无需登录也可进入。
3. 当 `meta.requireAuth` 为 true 时，判断在 Vuex 中保存的 isLogin 为 true 还是 false，为 true 表示已登录，那么执行 `next()` 即可正常导航；为 false 表示未登录，按照之前的说明，将跳转到登录页面。

全局前置守卫有三个参数 to、from、next：

1. `to: Route`：即将要进入的路由对象，包含路由名称、路径、参数等。
2. `from: Route`：当前导航正要离开的路由对象。
3. `next: Function`：在全局前置守卫中， 一定要调用该方法来 **resolve** 这个钩子。执行效果依赖 `next` 方法的调用参数：`next()`无参数时， 进行管道中的下一个钩子；`next(false)` 参数为 false 时，中断当前的导航；`next({ path: '/' })` 跳转到一个不同的地址，当前的导航被中断，然后进行一个新的导航。 `next` 支持传递任意位置对象，且允许设置诸如 `replace: true`、`name: 'home'` 之类的选项以及任何用 [`router-link` 的 `to` prop](https://router.vuejs.org/zh/api/#to) 或 [`router.push`](https://router.vuejs.org/zh/api/#router-push) 中的选项。

在 `src/main.js` 中引入刚才创建好的 `before.js`：

```javascript
import '@/router/before.js'
```

现在我们来直接进入首页，发现接口请求返回的 false，页面直接跳转到了登录页面，并且带了查询参数 `Rurl`：

![12-8](https://doc.shiyanlou.com/courses/3472/1557563/5e30c3525c906735cd097327dfd9821c-0/wm)

然后来给登录、注册页面在登录状态下添加自动跳转到首页的效果，在 `src/views/Login.vue` 中的生命周期 `created()` 中添加登录状态判断：

```javascript
<script>
import { login } from '@/request/user.js'	//	引入登录接口
import Cookies from 'js-cookie'

export default {
  name: 'Login',
  data() {
    return {
      // ......
    }
  },
  created() {
    if (this.$store.getters.isLogin) {
      // 用户若已登录，自动跳转到首页
      this.$notify({
          title: '成功',
          message: '您已登录！已跳转到首页',
          type: 'success'
      })
      this.$router.replace({ name: 'Home' })
    }
  },
  methods: {
    ...
```

注册页面同理，在 `created` 中添加同样的处理。修改 `Register.vue` 文件，添加如下代码：

```vue
<script>
import { addUser } from '@/request/user.js' //	引入注册接口

export default {
  name: 'Register',
  data() {
    return {
      // ......
    }
  },
  created() {
    if (this.$store.getters.isLogin) {
      // 用户若已登录，自动跳转到首页
      this.$notify({
        title: '成功',
        message: '您已登录！已跳转到首页',
        type: 'success'
      })
      this.$router.replace({ name: 'Home' })
    }
  },
  methods: {
    ...  
```

用之前注册的账号登录，跳转到首页：

![12-9](https://doc.shiyanlou.com/courses/3472/1557563/516e8e54a22063fe4079571577c79856-0)

然后在登录状态下进入登录和注册页面，可以看到会自动跳转到首页：

<img src="https://doc.shiyanlou.com/courses/3472/1557563/e6c411e873171ede253e69380304381d-0/wm" alt="12-10" style="zoom:67%;" />

如果在路由跳转中，控制台打印了错误提示，尝试在 `src/router/index.js` 中的文末添加以下代码：

```javascript
const originalPush = VueRouter.prototype.push;
VueRouter.prototype.push = function push(location) {
  return originalPush.call(this, location).catch(err => err)
};
```

### 退出登录状态

来完善下我们的用户登录、页面跳转到退出登录的流程：

1. 在已登录时，导航栏添加退出菜单，未登录时隐藏此菜单。
2. 在已登录时，隐藏登录和注册菜单，并显示用户名，未登录时显示这两个菜单，并隐藏用户名。
3. 登录状态和用户名均保存在 Vuex 中，可以通过 computed 获取。

在 `src/components/Header.vue` 中添加以下内容：

```vue
<template>
  <el-menu
    class="header-menu"
    :default-active="activeIndex"
    :router="true"
    mode="horizontal"
  >
    <el-menu-item index="Home" :route="{ name: 'Home' }">首页</el-menu-item>
    <el-menu-item
      class="login"
      index="Login"
      :route="{ name: 'Login' }"
      v-show="!isLogin"
      >登录</el-menu-item
    >
    <el-menu-item
      class="register"
      index="Register"
      :route="{ name: 'Register' }"
      v-show="!isLogin"
      >注册</el-menu-item
    >
    <!-- 为了和其他菜单样式保持一致，请一定要添加类名 el-menu-item -->
    <div class="el-menu-item exit" @click="exitButton()" v-show="isLogin">
      退出
    </div>
    <!-- 为了和其他菜单样式保持一致，请一定要添加类名 el-menu-item -->
    <div class="el-menu-item username" v-show="isLogin">
      <!-- 图标来自于Element UI官方图标库 -->
      <i class="el-icon-user-solid"></i>{{ username }}
    </div>
  </el-menu>
</template>

<script>
import Cookies from 'js-cookie'

export default {
  name: 'Header',
  data() {
    return {}
  },
  computed: {
    // 当前激活菜单的 index
    activeIndex() {
      return this.$route.name //  获取当前路由名称
    },
    // 登录状态
    isLogin() {
      return this.$store.getters.isLogin
    },
    // 用户名
    username() {
      return this.$store.getters.username
    }
  },
  methods: {
    // 退出登录
    exitButton() {
      Cookies.set('token', '')
      this.$router.push({ path: '/login' }) //  退出登录后跳转到登录页面
      this.$message.success('退出登录成功！')
    }
  }
}
</script>

<style lang="stylus" scoped>
.header-menu {
  padding: 0 24px;

  .login, .register, .username, .exit {
    float: right;
  }
}
</style>
```

来看下登录、跳转到首页、退出登录流程的效果：

<img src="https://doc.shiyanlou.com/courses/3472/1557563/c5a344b3c32f52e285db61ce18bda0ec-0/wm" alt="12-11" style="zoom:67%;" />

## 实验总结

此次实验介绍了 Axios 的安装，接口的封装和使用，在页面编写过程中使用了 Element UI 的 Form 表单组件 ，并介绍了路由全局前置守卫，完成了登录到退出登录的状态保存和页面跳转。有兴趣的同学可以对登录、注册界面的表单校验和接口做优化，例如表单校验对手机号添加号码长度限制，密码添加格式校验和密码强度校验，添加短信验证码、图形验证码或行为验证码等。

本次实验完整代码可以通过如下命令进行下载：

```bash
wget https://labfile.oss.aliyuncs.com/courses/3472/code12.zip
```
