---
show: step
version: 1.0
enable_checker: true
---

# 数据库设计流程及 JPA 的使用

## 实验介绍

这节实验主要讲解网盘项目需求分析过程，然后教大家使用 E-R 图来进行数据库的建模，并使用 JPA 技术创建数据库表。

#### 知识点

- 需求分析
- 数据库建模
- JPA 建表

#### 开发计划

- 开发内容：本次实验带领大家完成项目需求分析，数据建模及数据库表的创建。
- 开发耗时：实验预计完成时间为 1~2 小时
- 开发难点：
1. 通过需求分析独立完成模型数据从抽象到具体的转换过程
2. 使用 JPA 技术完成数据库的建表。

## 需求分析

在数据库建模之前，首先要做的就是需求分析，目的是对将要设计的系统有一个足够的认识，接下来我将带领大家来分析一个网盘系统，并一步步去实现它。

#### 文件的概念

网盘系统主要是对文件进行管理，因此我们需要对文件有一个清晰的认识，我这里列出几个比较重要的点：

1. 文件分为普通文件和目录文件。
2. 普通文件是真实存在的，保存在磁盘空间的一个二进制文件，因此它具有真实的文件路径和大小。
3. 目录文件是虚拟的，它存在的目的是对普通文件进行分类归档。

#### 文件的物理存储和逻辑存储

在计算机内部，由于文件都是以二进制的形式进行存储的，因此一个文件实际上就是一个二进制文件，占用一定的磁盘空间，这就是文件的**物理存储**。而作为一个网盘项目，我们在界面上展示的文件信息实际上只是在数据库存储的数据信息，包括文件路径，文件大小，文件名等，但是它会通过一个 url 字段指向服务器的一个具体文件，这就是**逻辑存储**。如下图：

![图片描述](https://doc.shiyanlou.com/courses/3472/1557563/d899bd3dd73c22d90495f2c19f84c67a-0/wm)

## 数据库建模

数据库建模，就是对现实世界进行分析、抽象、并从中找出内在联系，进而确定数据库的结构，这一过程就称为数据库建模。它主要包括两部分内容：

1. 确定最基本的数据结构
2. 对约束建模。

这里我先给出一个简单的需求说明，然后根据这个需求，我们来一步步实现一个完整的数据库建模过程。

#### 需求说明

实现一个网盘项目，然后实现用户登录，登录用户可以对文件进行管理，其中包含以下功能：

1. 文件的上传，删除，列表展示，修改名称
2. 文件的移动，文件的复制

#### 根据需求说明提取实体和属性

从上面需求描述，我们需要从中提取出实体和属性，如下表：

|实体|属性|
|-|-|
|文件|文件名、扩展名、大小、路径、...|
|用户|用户名、手机号、密码、年龄、...|

上表只是给出了一个示例，你可以根据自己的理解和实际需要对属性进行扩展，当实体和属性提取出来之后，就可以对实体和属性，实体和实体之间的关系进行分析，这个分析过程需要用 E-R 图，下面借助 E-R 图来说明整个分析过程。

### E-R 图

E-R 图也称为实体-联系图（Entity Relationship Diagram），它提供了表示实体类型、属性和联系的方法，用来描述现实世界的概念模型。

在 E-R 图中，分别用矩形、菱形、椭圆形来表示不同的含义，如下表：

|形状|含义|
|-|-|
|矩形|实体|
|菱形|实体之间的联系|
|椭圆形|实体或联系的属性|

了解了 E-R 图的规则之后，现在我们将上面的文件和用户这两个实体 E-R 图表示出来，如下图：

- 文件

![图片描述](https://doc.shiyanlou.com/courses/3472/1557563/a254eb024df03523608ac5da27ceaa1e-0/wm)

- 用户

![图片描述](https://doc.shiyanlou.com/courses/3472/1557563/03ac92c81e68e78ce68f9a0ce09a2f42-0/wm)

### 文件与用户的关系

由于文件是需要用户去进行管理的，因此这里要清楚文件和用户之间的关系，是一对一、一对多、还是多对多，然后在 ER 图中将他们关联起来。

要搞清楚他们之间的关系，首先需要明确下面两个问题：

1. 一个用户能否拥有多个文件
2. 一个文件是否可以被多个用户所拥有

作为一个网盘系统，一个用户肯定是能够拥有多个文件，主要关键在于一个文件是否可以被多个用户所拥有，由于后面我们要实现极速秒传的功能，那么这里就会涉及到，一个文件被多个用户所拥有。

从以上两个问题的分析结果，可以得出用户和文件之间是多对多的关系，因此在 ER 图中，我们可以将文件和用户关联起来，如下图：

![图片描述](https://doc.shiyanlou.com/courses/3472/1557563/e96a636ce60ee5c8b06cc7131985a754-0/wm)

从上图可以看出，两个实体之间进行关联需要用到菱形，在菱形的两边用 M 进行标识，表示两个实体类之间是多对多的关系。

### 将多对多联系转为一对多联系模型

在数据库设计中，如果两个实体之间是多对多的关系，那么就需要一张中间表进行关联，从而将多对多联系转为一对多联系模型。这个操作是关键点，也是难点，因为之前的两个实体都是直观的，现在就需要抽象出来一个新的实体。

我们将这种中间表起名为用户文件表，它存在的意义就是将文件表和用户表关联起来，如下图：

![图片描述](https://doc.shiyanlou.com/courses/3472/1557563/87d4eed2c6e530a118aaa9de9deb2f49-0/wm)

到此为止，整个数据库底层的关系模型就已经出来了，在此之前，我们所说的文件还是一个模糊的概念，而到了这一步，整个关系模型跟之前讲物理存储和逻辑存储的图正好能够对应，其中文件就是物理存储，它跟磁盘存储的文件是一一对应的，用户文件属于逻辑存储，用户在前台对文件进行移动复制等操作，其实只是做一些数据库的操作，但是指向文件的 url 没有变动，这就恰恰反向论证了整个设计思路是没有问题的。

根据上图，这里还需要做进一步的解释，我们发现，在整个 E-R 图的演进过程中，本来属于文件的属性，我却把它放到了用户文件这一层，比如文件名，扩展名，是否是目录，其原因是修改文件名和扩展名，是不会影响文件本身的二进制内容，你可以不妨一试，因此我将它放到逻辑存储的用户文件属性中了。另外我们在文件磁盘存储的角度是不存在目录这个概念的，它只是我们在管理层面抽象出来的，因此它也需要提升到用户文件这个实体类中。

## JPA 建表

JPA（Java Persistence API)，中文名 Java 持久层 API，是 Java 持久化规范，简单的理解就是它为 Java 开发者提供了一个对象映射工具，可以使用这个工具，建立一个 Java 数据模型与数据库表结构之间的一种关系，并将 Java 的数据模型映射到数据库并建立数据库表结构，当然它还有众多的优点，在这里我们重点介绍它的使用方法。

#### 引入依赖

向 `pom.xml` 文件中补充如下依赖：

```xml
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>

<dependency>
	<groupId>org.projectlombok</groupId>
	<artifactId>lombok</artifactId>
	<optional>true</optional>
</dependency>
```

上面这段代码引入了两个依赖：

第一个依赖就是 jpa 的依赖包，第二个依赖是 Lombok 依赖，Lombok 提供了一组有用的注解，用来消除 Java 类中的大量样板代码。仅五个字符（@Data）就可以替换数百行代码从而产生干净，简洁且易于维护的 Java 类。

#### 添加配置文件

打开 `application.proterties` 文件，添加如下内容：

```properties
#jpa 配置
spring.jpa.properties.hibernate.hbm2ddl.auto=update
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5InnoDBDialect
spring.jpa.show-sql=true
spring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl
```

需要注意的是最后一行配置，用来定义命名策略，如果不设置，会使用默认的命名策略，比如建表时，会将有驼峰命名的转换为全小写，并用横线分割如：实体类名：userCommon，映射到表名就是 user-common。

### 创建实体类

打开项目，在 `com.shiyanlou.file` 包下创建一个 `model` 的包，这个包就用来存放我们的实体类对象。

在这个包下，我们需要创建三个 Java 类，用来存放之前设计的实体。接下来我们首先创建一张用户的实体类，并添加 jpa 相关的注解。

#### 用户实体类

新建 `User.java` 文件，并向其中写入如下代码：

```java
package com.shiyanlou.file.model;

import lombok.Data;

import javax.persistence.*;

@Data
@Table(name = "user")
@Entity
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(columnDefinition = "bigint(20) comment '用户id'")
    private Long userId;

    @Column(columnDefinition = "varchar(30) comment '用户名'")
    private String username;

    @Column(columnDefinition = "varchar(35) comment '密码'")
    private String password;

    @Column(columnDefinition = "varchar(15) comment '手机号码'")
    private String telephone;

    @Column(columnDefinition = "varchar(20) comment '盐值'")
    private String salt;

    @Column(columnDefinition = "varchar(30) comment '注册时间'")
    private String registerTime;

}
```

上面是一个用户实体类，里面的用户属性我只列出了登录所需的关键属性，你可以根据自己的需要补充其他用户属性，比如年龄，性别，省市区等。上面涉及到的 jpa 注解，它的含义如下表：

|注解名称|说明|
|-|-|
|@Entity|表明该类是一个实体类，添加了该注解后，才能被 jpa 扫描到|
|@Table|可以自定义表名|
|@Id|用来声明主键|
|@GeneratedValue|设置主键生成方式，主要有四种类型，这里我们将 strategy 属性设置为 GenerationType.IDENTITY，表明主键由数据库生成，为自动增长型|
|@Column|可以自定义列名或者定义其他的数据类型|

#### 文件实体类

新建 `File.java` 文件，并向其中写入如下代码：

```java
package com.shiyanlou.file.model;

import lombok.Data;

import javax.persistence.*;

@Data
@Table(name = "file")
@Entity
public class File {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(columnDefinition="bigint(20) comment '文件id'")
    private Long fileId;

    @Column(columnDefinition="varchar(500) comment '时间戳名称'")
    private String timeStampName;

    @Column(columnDefinition="varchar(500) comment '文件url'")
    private String fileUrl;

    @Column(columnDefinition="bigint(10) comment '文件大小'")
    private Long fileSize;

}

```

#### 用户文件实体类

新建 `UserFile.java` 文件，并向其中写入如下代码：

```java
package com.shiyanlou.file.model;

import lombok.Data;

import javax.persistence.*;

@Data
@Table(name = "userfile", uniqueConstraints = {
        @UniqueConstraint(name = "fileindex", columnNames = {"fileName", "filePath", "extendName"})})
@Entity
public class UserFile {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(columnDefinition = "bigint(20) comment '用户文件id'")
    private Long userFileId;

    @Column(columnDefinition = "bigint(20) comment '用户id'")
    private Long userId;

    @Column(columnDefinition="bigint(20) comment '文件id'")
    private Long fileId;

    @Column(columnDefinition="varchar(100) comment '文件名'")
    private String fileName;

    @Column(columnDefinition="varchar(500) comment '文件路径'")
    private String filePath;

    @Column(columnDefinition="varchar(100) comment '扩展名'")
    private String extendName;

    @Column(columnDefinition="int(1) comment '是否是目录 0-否, 1-是'")
    private Integer isDir;

    @Column(columnDefinition="varchar(25) comment '上传时间'")
    private String uploadTime;

}

```

### 启动项目

这里需要注意的是，在启动项目的时候，数据库的创建工作必须提前完成，否则在启动的时候会报数据库连接失败，由于实验一我们已经完成了数据库的创建，这里我就不再重复演示了。

启动的具体命令如下所示：

```bash
cd /home/project/qiwen-file
mvn spring-boot:run
```

启动之后，可以观察控制台的打印，启动成功之后，控制台会打印出相关的建表语句，此时我们可以进入数据库来查看创建的表，命令如下。

使用命令 `mysql -uroot` 连接数据库，并切换到 file 数据库：

```sql
use file;
```

![图片描述](https://doc.shiyanlou.com/courses/3472/1557563/f7a42f8d450e91112593a19d789640e3-0/wm)

因为我们在项目中创建了三个实体类，那么项目启动之后就会通过 JPA 生成三张表，查看当前数据库中的表：

```sql
show tables;
```

如下图：

![图片描述](https://doc.shiyanlou.com/courses/3472/1557563/327b324eff026c2c6637eb5a852ca0a0-0/wm)

使用 `desc 表名` 命令查看表结构，如下图：

```sql
desc file;
desc user;
desc userfile;
```

![图片描述](https://doc.shiyanlou.com/courses/3472/1557563/ded03310e494c60cd990887555c7d674-0/wm)

![图片描述](https://doc.shiyanlou.com/courses/3472/1557563/a40bcdedf4c69e2a18c21f9f8135080d-0/wm)

![图片描述](https://doc.shiyanlou.com/courses/3472/600404/8775a8cfdeb3726463060383e0221d8d-0/wm)

## 实验总结

本节实验课程向大家讲述了网盘需求的分析和设计过程，在学习的过程中，重点要掌握整个操作流程，这样在遇到一个新的项目自己也可以去分析和建模。当然，需求的变化和修改是很常见的，作为本项目也是一样的，但是我们能做到的架构是完善的，底层是可靠的，这样遇到新需求才能保证它的可扩展性。

本次实验完整代码可以通过如下命令进行下载：

```bash
wget https://labfile.oss.aliyuncs.com/courses/8842/code2.zip
```
