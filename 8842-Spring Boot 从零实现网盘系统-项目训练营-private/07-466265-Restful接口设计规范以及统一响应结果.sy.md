---
show: step
version: 1.0
enable_checker: true
---

# RESTful 接口设计规范及统一响应结果

## 实验介绍

本实验主要讲解 RESTful 基本概念，包括请求方法、URL 设计、服务器响应等，使得大家能够学到一个真正的 RESTful 接口应该如何去设计，然后带领大家在代码中对后台异常进行统一处理，保证程序能够完整的执行下去。

#### 知识点

- RESTful 基本概念
- 后台统一返回结果
- 统一异常处理

#### 开发计划

- 开发内容：
1. 介绍 RESTful 接口设计规范，并能够使用该规范进行接口开发
2. 通过统一异常处理来进行异常场景下的全局返回处理。
- 开发耗时：实验预计完成时间为 1~2 小时
- 开发难点：
1. 在开发一个新的接口命名需要符合 RESTful 规范，包括 HTTP 请求方法，url 路径和格式，后台统一返回格式等。
2. 返回码的格式和含义需要按照业务场景规划。

## RESTful 基本概念

RESTful 是一种网络应用程序的设计风格和开发方式，给出一种约定的标准，包含 API 接口规范、命名规则、URL、返回值、授权验证等，下面就介绍几种主要的设计规范，当我们在项目编写当中需要尽可能的去遵守。

#### 正确使用 HTTP 请求方法

HTTP 请求有 5 种请求方法，对应 CRUD 操作，通常我们使用 GET 来做查询，POST 做提交。

- GET：读取（Read）
- POST：新建（Create）
- PUT：更新（Update）
- PATCH：更新（Update），通常是部分更新
- DELETE：删除（Delete）

#### url 路径

既然上面 HTTP 请求方法已经为我们指定了请求的动作，那么请求的 url 路径只需要指定好需要请求的资源就可以了，它是名词，而非动词，或者动宾，比如 `/articles` 就是正确的，而下面的 URL 不是名词，所以是错误的：

- `/getArticles`
- `/createNewCar`
- `/deleteAllRedCars`

#### URL 格式

URL 是不区分单数和复数的，通常的做法是当读取一个集合，比如 `GET /articles`，则表示读取所有文章，`GET /articles/3` 则表示读取某一篇文章。

#### 避免 URL 嵌套过深

常见的情况是，资源需要多级分类，因此很容易写出多级的 URL，比如获取某个作者的某一类文章。

```text
GET /authors/12/categories/2
```

这种 URL 不利于扩展，语义也不明确，往往要想一会，才能明白含义。更好的做法是，除了第一级，其他级别都用查询字符串表达。

```text
GET /authors/12?categories=2
```

下面是另一个例子，查询已发布的文章。你可能会设计成下面的 URL。

```text
GET /articles/published
```

查询字符串的写法明显更好。

```text
GET /articles?published=true
```

#### 服务器响应

接口的 API 返回的数据格式，不应该是纯文本，而应该是一个 JSON 对象，因为这样才能返回标准的结构化数据。所以，服务器回应的 HTTP 头的 Content-Type 属性要设为 `application/json`。
目前的前后端开发大部分数据的传输格式都是 JSON，因此定义一个统一规范的数据格式有利于前后端的交互与 UI 的展示。

## 后台统一返回结果

在了解 RESTful 基本概念之后，接下来就带领大家进行代码实现，当设计后台接口时，我们需要统一返回格式，这里我们首先使用枚举类来定义各种返回状态。

### 定义结果枚举类

一般后台返回给前台的状态可以大致分为两类：成功和失败，但是失败的情况却有很多种，为了能够让前台调用者更加清楚的知道后台报了什么错，这里我们可以尽可能的将错误细化，比如下面枚举类中参数错误，空指针异常等。

创建一个 `com.shiyanlou.file.common` 包用来存放一些公共类，创建返回码的枚举类 `ResultCodeEnum.java` 放到这个包下面，如下：

```java
package com.shiyanlou.file.common;

import lombok.Getter;

/**
 * 结果类枚举
 */
@Getter
public enum ResultCodeEnum {
    SUCCESS(true,20000,"成功"),
    UNKNOWN_ERROR(false,20001,"未知错误"),
    PARAM_ERROR(false,20002,"参数错误"),
    NULL_POINT(false, 20003, "空指针异常"),
    INDEX_OUT_OF_BOUNDS(false, 20004, "下标越界异常"),
    ;

    // 响应是否成功
    private Boolean success;
    // 响应状态码
    private Integer code;
    // 响应信息
    private String message;

    ResultCodeEnum(boolean success, Integer code, String message) {
        this.success = success;
        this.code = code;
        this.message = message;
    }
}
```

### 定义统一结果返回类

在 `com.shiyanlou.file.common` 包下继续定义 `RestResult.java` 类，该类用于定义后台统一返回格式。

```java
package com.shiyanlou.file.common;

import lombok.Data;

/**
 * 统一结果返回
 *
 * @param <T>
 */
@Data
public class RestResult<T> {
    private Boolean success = true;
    private Integer code;
    private String message;
    private T data;

    // 通用返回成功
    public static RestResult success() {
        RestResult r = new RestResult();
        r.setSuccess(ResultCodeEnum.SUCCESS.getSuccess());
        r.setCode(ResultCodeEnum.SUCCESS.getCode());
        r.setMessage(ResultCodeEnum.SUCCESS.getMessage());
        return r;
    }

    // 通用返回失败，未知错误
    public static RestResult fail() {
        RestResult r = new RestResult();
        r.setSuccess(ResultCodeEnum.UNKNOWN_ERROR.getSuccess());
        r.setCode(ResultCodeEnum.UNKNOWN_ERROR.getCode());
        r.setMessage(ResultCodeEnum.UNKNOWN_ERROR.getMessage());
        return r;
    }

}
```

上面这段代码就是统一结果返回类，到目前为止，我们创建了两个类，分别是 `ResultCodeEnum.java` 和 `RestResult.java`， 创建完成结果如下图：

![图片描述](https://doc.shiyanlou.com/courses/3472/1557563/33c4d75b3bafd4d83bbd72ba0b814977-0/wm)

### 返回结果测试

接下来我们对上面的代码进行测试，创建一个 `com.shiyanlou.file.controller` 包用来存放接口，在包下创建文件：`UserController.java`，打开该文件，初始化内容如下：

```java
package com.shiyanlou.file.controller;

import com.shiyanlou.file.common.RestResult;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;
import com.shiyanlou.file.common.RestResult;

@RestController
@RequestMapping("/user")
public class UserController {

    /**
     * 成功响应测试
     */
    @GetMapping(value="/test1")
    @ResponseBody
    public RestResult test1(){
        return RestResult.success();
    }

    /**
     * 失败响应测试
     */
    @GetMapping(value="/test2")
    @ResponseBody
    public RestResult test2(){
        return RestResult.fail();
    }
}
```

启动项目进行测试（`Application.java` 文件），启动成功之后，点击右侧 Web 服务进行测试，在浏览器上面的地址栏追加内容：`/user/test1`，查看后台返回，如下图是模拟成功响应：

![图片描述](https://doc.shiyanlou.com/courses/3472/1557563/72cf062441559f832ab255b2cce61072-0/wm)

在浏览器上面的地址栏追加内容： `/user/test2`，查看后台返回，如下图是模拟失败响应：

![图片描述](https://doc.shiyanlou.com/courses/3472/1557563/8e60c726fb45d7486a36493fd37ea29f-0/wm)

上面这段代码我们可以称它们为通用的成功或失败响应码，但是有些情况，当系统返回失败的时候我们需要自定义返回码或者返回信息，因此需要在 RestResult 结果类里面添加方法，来满足各种错误场景。

打开 `RestResult.java` 类，添加如下代码：

```java
// 自定义返回数据
public RestResult data(T param) {
    this.setData(param);
    return this;
}

// 自定义状态信息
public RestResult message(String message) {
    this.setMessage(message);
    return this;
}

// 自定义状态码
public RestResult code(Integer code) {
    this.setCode(code);
    return this;
}

// 设置结果，形参为结果枚举
public static RestResult setResult(ResultCodeEnum result) {
    RestResult r = new RestResult();
    r.setSuccess(result.getSuccess());
    r.setCode(result.getCode());
    r.setMessage(result.getMessage());
    return r;
}
```

上面这三个方法分别用来自定义返回数据，状态码和状态信息，具体的使用方法如下：

```java

//查询文件列表
public RestResult list() {
    List<File> filelist = new ArrayList<File>();
    //获取文件列表（略）
    ...
    return RestResult.fail().data(filelist);
}

//模拟用户登录失败响应场景
public RestResult loginFailResult() {
    return RestResult.fail().message("手机号不存在！");
}
```

## 统一异常处理

在我们编程的过程中，并不是百分之百的接口都能通过正常的方式调用及返回，往往还会有一些异常场景，比如代码中经常出现数据下标越界，空指针异常等异常场景，而这些场景都是不可控的，一旦发生，程序流程就会终止，此时如果不对这种场景进行处理，那么就会造成前台无响应的局面。

### 异常处理类

异常处理类的原理就是通过 AOP 进行拦截，AOP 就是面向切面编程，而我们这里使用的切面实在控制层进行切面拦截，当发生异常时就会执行异常处理类。

创建 `com.shiyanlou.file.advice` 包，在这个包下新建 `GlobalExceptionHandlerAdvice.java`, 代码如下：

```java
package com.shiyanlou.file.advice;

import com.shiyanlou.file.common.RestResult;

import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseBody;

import lombok.extern.slf4j.Slf4j;

@Slf4j
@ControllerAdvice
public class GlobalExceptionHandlerAdvice {
    /**-------- 通用异常处理方法 --------**/
    @ExceptionHandler(Exception.class)
    @ResponseBody
    public RestResult error(Exception e) {
        e.printStackTrace();
        log.error("全局异常捕获：" + e);

        return RestResult.fail();    // 通用异常结果
    }
}
```

上面代码涉及到几个重要的注解，说明如下表：

|注解|说明|
|-|-|
|@ControllerAdvice|这是一个增强的 Controller。使用这个 Controller ，可以实现三个方面的功能：1、全局异常处理， 2、全局数据绑定， 3、全局数据预处理|
|@ExceptionHandler|该注解用来指明异常的处理类型|
|@ResponseBody|该注解为 Spring Boot 响应体注解，用在这里的目的就是当出现异常时，直接将错误返回给前台，可以避免前台页面阻塞|

上面我们使用了大异常 `Exception` 来进行处理，不管发生任何异常都会执行该方法，当然在实际当中，我们也可以将异常进行细化，使得前台返回的错误更加具体，继续在该 `GlobalExceptionHandlerAdvice.java` 文件中添加下面代码：

```java
import com.shiyanlou.file.common.ResultCodeEnum;

@Slf4j
@ControllerAdvice
public class GlobalExceptionHandlerAdvice {
    ...
    @ExceptionHandler(NullPointerException.class)
    @ResponseBody
    //空指针处理方法
    public RestResult error(NullPointerException e) {
        e.printStackTrace();
        log.error("全局异常捕获：" + e);
        return RestResult.setResult(ResultCodeEnum.NULL_POINT);
    }

    //下标越界处理方法
    @ExceptionHandler(IndexOutOfBoundsException.class)
    @ResponseBody
    public RestResult error(IndexOutOfBoundsException e) {
        e.printStackTrace();
        log.error("全局异常捕获：" + e);
        return RestResult.setResult(ResultCodeEnum.INDEX_OUT_OF_BOUNDS);
    }
}
```

上面两个示例方法就是对不同的异常进行返回，你也可以添加其他的异常，具体做法是一样的，当然我们在代码里面还会有一些自定义异常，其做法也是一样的。

### 测试

在 `UserController.java` 类中添加如下代码进行测试：

```java
/**
* 空指针异常响应测试
*/
@GetMapping(value="/test3")
@ResponseBody
public RestResult test3(){
    String s = null;
    int i = s.length();
    return RestResult.success();
}
```

上面这段代码我构造了一个空指针异常，一旦程序报错，拦截器就会进行处理，并将错误信息返回给前台。

启动项目进行测试，启动成功之后，点击右侧 web 服务进行测试，在浏览器上面的地址栏追加内容：`/user/test3`，查看后台返回，如下图是模拟成功响应：

![图片描述](https://doc.shiyanlou.com/courses/3472/1557563/3d63f0189d10d99f624dc0982335035c-0/wm)

## 实验总结

本实验主要讲解了 RESTful 接口规范，统一响应结果，统一异常处理在代码开发中的应用，在实际项目开发中，我们一定要严格按照约定来开发接口，才能使得整个项目能够符合行业规范。

本次实验完整代码可以通过如下命令进行下载：

```bash
wget https://labfile.oss.aliyuncs.com/courses/8842/code4.zip
```
