---
show: step
version: 1.0
enable_checker: true
---

# 后台接口开发实战 2—文件切片上传和极速上传接口开发

## 实验介绍

本节实验带领大家来完成文件的切片上传和极速上传接口开发，并了解其原理。

#### 知识点

- 抽象工厂方法
- 上传文件接口开发
- 下载文件接口开发

#### 开发计划

- 开发内容：文件切片上传和极速上传后台接口开发。

- 开发耗时：实验预计完成时间为 4~6 小时
- 开发难点：
1. 熟练使用抽象工厂模式，能够借助类图进行代码结构设计。
2. 理解文件切片上传原理。

## 引入依赖

下面引入两个依赖，分别是 `commons-io` 和 `thumbnailator` 在 commons-io 中封装了很多对输入输出流的操作，这在后面的开发过程中需要用到，`thumbnailator` 是一个用来生成图像缩略图的 Java 类库，通过很简单的代码即可生成图片缩略图，也可直接对一整个目录的图片生成缩略图，向 `pom.xml` 文件中添加如下代码：

```xml
<dependency>
    <groupId>commons-io</groupId>
    <artifactId>commons-io</artifactId>
    <version>2.8.0</version>
</dependency>
<dependency>
    <groupId>net.coobird</groupId>
    <artifactId>thumbnailator</artifactId>
    <version>0.4.13</version>
</dependency>
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>fastjson</artifactId>
    <version>1.2.75</version>
</dependency>
```

## 配置文件

Spring Boot 默认会限制文件上传文件大小 2M，超过该大小的文件都会上传失败，因此需要在配置文件中修改该限制，向 `application.properties` 文件中补充如下代码：

```java
#上传下载
spring.servlet.multipart.max-file-size=100MB
spring.servlet.multipart.max-request-size=100MB
spring.servlet.multipart.enabled=true

#文件存储类型
file.storage-type=0
```

## 创建统一异常类

#### 文件 md5 校验失败异常

在 `com.shiyanlou.file` 包下创建 `exception` 文件夹，并在该文件夹下创建 `NotSameFileExpection.java` 文件，写入如下代码：

```java
package com.shiyanlou.file.exception;

public class NotSameFileExpection extends Exception {
    public NotSameFileExpection() {
        super("File MD5 Different");
    }
}
```

#### 上传异常

在 `com.shiyanlou.file.exception` 包下创建 `UploadException.java` 文件，向其中写入如下代码：

```java
package com.shiyanlou.file.exception;

public class UploadException extends RuntimeException {
    public UploadException(Throwable cause) {
        super("上传出现了异常", cause);
    }

    public UploadException(String message) {
        super(message);
    }

    public UploadException(String message, Throwable cause) {
        super(message, cause);
    }
}
```

## 创建常用工具类

#### 获取配置文件类

在 Spring Boot 中，有多种方式可以轻松获取到 application.properties 配置文件中的配置参数，但提供的默认都是基于 Spring 体系，当我们在静态工具类中想要获取配置参数，则需要使用如下方式进行获取：

在 `com.shiyanlou.file.config` 包下新建 `PropertiesConfig.java` 类，用来读取环境变量：

```java
package com.shiyanlou.file.config;

import javax.annotation.PostConstruct;
import javax.annotation.Resource;

import com.shiyanlou.file.util.PropertiesUtil;

import org.springframework.context.annotation.Configuration;
import org.springframework.core.env.Environment;

@Configuration
public class PropertiesConfig {

	@Resource
	private Environment env;

	@PostConstruct
	public void setProperties() {
		PropertiesUtil.setEnvironment(env);
	}

}
```

在 `com.shiyanlou.file.util` 包下，创建 `PropertiesUtil.java`，通过该类的 `getProperty` 方法，可以获取 `application.properties` 中的配置，代码如下：

```java
package com.shiyanlou.file.util;

import org.springframework.core.env.Environment;

public class PropertiesUtil {
    private static Environment env = null;

	public static void setEnvironment(Environment env) {
		PropertiesUtil.env = env;
	}

	public static String getProperty(String key) {
		return PropertiesUtil.env.getProperty(key);
	}

}
```

#### 文件工具类

在 `com.shiyanlou.file.util` 包下创建 `FileUtil.java` 类，该类用来定义文件的一些常用操作方法，代码如下：

```java
package com.shiyanlou.file.util;

public class FileUtil {
    public static final String[] IMG_FILE = {"bmp", "jpg", "png", "tif", "gif", "jpeg"};
    public static final String[] DOC_FILE = {"doc", "docx", "ppt", "pptx", "xls", "xlsx", "txt", "hlp", "wps", "rtf", "html", "pdf"};
    public static final String[] VIDEO_FILE = {"avi", "mp4", "mpg", "mov", "swf"};
    public static final String[] MUSIC_FILE = {"wav", "aif", "au", "mp3", "ram", "wma", "mmf", "amr", "aac", "flac"};
    public static final int IMAGE_TYPE = 1;
    public static final int DOC_TYPE = 2;
    public static final int VIDEO_TYPE = 3;
    public static final int MUSIC_TYPE = 4;
    public static final int OTHER_TYPE = 5;
    public static final int SHARE_FILE = 6;
    public static final int RECYCLE_FILE = 7;
    /**
     * 判断是否为图片文件
     *
     * @param extendName 文件扩展名
     * @return 是否为图片文件
     */
    public static boolean isImageFile(String extendName) {
        for (int i = 0; i < IMG_FILE.length; i++) {
            if (extendName.equalsIgnoreCase(IMG_FILE[i])) {
                return true;
            }
        }
        return false;
    }
    /**
     * 获取文件扩展名，如果没有扩展名，则返回空串
     * @param fileName 文件名
     * @return 文件扩展名
     */
    public static String getFileExtendName(String fileName) {
        if (fileName.lastIndexOf(".") == -1) {
            return "";
        }
        return fileName.substring(fileName.lastIndexOf(".") + 1);
    }

    /**
     * 获取不包含扩展名的文件名
     *
     * @param fileName 文件名
     * @return 文件名（不带扩展名）
     */
    public static String getFileNameNotExtend(String fileName) {
        String fileType = getFileExtendName(fileName);
        return fileName.replace("." + fileType, "");
    }
}
```

#### 路径工具类

在 `com.shiyanlou.file.util` 包下创建 `PathUtil.java` 类，该类用来获取文件路径，代码如下：

```java
package com.shiyanlou.file.util;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.text.SimpleDateFormat;
import java.util.Date;

import org.apache.commons.lang3.StringUtils;
import org.springframework.util.ResourceUtils;

import lombok.extern.slf4j.Slf4j;

@Slf4j
public class PathUtil {

    public static String getFilePath() {
        
        String path = "upload";
        SimpleDateFormat formater = new SimpleDateFormat("yyyyMMdd");
        path = File.separator + path + File.separator + formater.format(new Date());

        String staticPath = PathUtil.getStaticPath();

        File dir = new File(staticPath + path);
        if (!dir.exists()) {
            try {
                boolean isSuccessMakeDir = dir.mkdirs();
                if (!isSuccessMakeDir) {
                    log.error("目录创建失败:" + PathUtil.getStaticPath() + path);
                }
            } catch (Exception e) {
                log.error("目录创建失败" + PathUtil.getStaticPath() + path);
                return "";
            }
        }
        return path;
    }
    
    public static String getStaticPath() {
        String localStoragePath = PropertiesUtil.getProperty("file.local-storage-path");
        if (StringUtils.isNotEmpty(localStoragePath)) {
            return localStoragePath;
        }else {
            String projectRootAbsolutePath = getProjectRootPath();
           
            int index = projectRootAbsolutePath.indexOf("file:");
            if (index != -1) {
                projectRootAbsolutePath = projectRootAbsolutePath.substring(0, index);
            }

            return projectRootAbsolutePath + "static" + File.separator;
        }


    }

    /**
     * 路径解码
     * @param url
     * @return
     */
    public static String urlDecode(String url){
        String decodeUrl = null;
        try {
            decodeUrl = URLDecoder.decode(url, "utf-8");
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        }
        return  decodeUrl;
    }

    /**
     * 获取项目所在的根目录路径 resources路径
     * @return
     */
    public static String getProjectRootPath() {
        String absolutePath = null;
        try {
            String url = ResourceUtils.getURL("classpath:").getPath();
            absolutePath = urlDecode(new File(url).getAbsolutePath()) + File.separator;
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

        return absolutePath;
    }

}
```

## 文件操作

下面通过代码来讲解如何对文件进行上传和下载，文件的存储形式有多种，我们可以选择将文件存储在本地，阿里云 OSS，七牛云或者 FastDFS 等等，可以说存储的方式有很多种，这里我们只实现其中的一种，但是为了以后便于扩展，我们需要通过抽象工厂的设计模式来对代码结构进行设计，这样做的好处就是能保证我们写的代码易于扩展，且对之前的代码没有影响。

### 抽象工厂模式类图

![图片描述](https://doc.shiyanlou.com/courses/3472/1557563/a61ef206557119979d85aec3f993c904-0/wm)

如上图，是我对整个文件操作的一个类图设计，最上层封装了三个具体的操作，分别是上传，下载和删除，然后第二层是对抽象接口的一个实现，因为目前我们只实现本地文件的操作，因此这里的实现类只有一个，如果后续有其他方式存储方式，可以继续横向扩展其实现类，再下面分别是抽象工厂和具体的工厂，主要是为了提供给外部来使用，整体的规划就是这样，接下来是对代码的实现。

### 文件上传

前端上传文件时如果文件很大，上传时会出现各种问题，比如连接超时了，网断了，都会导致上传失败。为了避免上传大文件时上传超时，就需要用到切片上传，工作原理是：我们将大文件切割为小文件，然后将切割的若干小文件上传到服务器端，服务器端接收到被切割的小文件，然后按照一定的顺序将小文件拼接合并成一个大文件。

#### 抽象类接口

创建 `com.shiyanlou.file.operation.upload` 包，并在该包下创建 `Uploader.java` 类，代码如下：

```java
package com.shiyanlou.file.operation.upload;

import java.io.File;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.List;

import javax.servlet.http.HttpServletRequest;

import com.shiyanlou.file.operation.upload.domain.UploadFile;
import com.shiyanlou.file.util.PathUtil;

import org.apache.commons.io.FileUtils;

import lombok.extern.slf4j.Slf4j;

@Slf4j
public abstract class Uploader {
    public static final String ROOT_PATH = "upload";
    public static final String FILE_SEPARATOR = "/";
    // 文件大小限制，单位KB
    public final int maxSize = 10000000;

    public abstract List<UploadFile> upload(HttpServletRequest request, UploadFile uploadFile);

    /**
     * 根据字符串创建本地目录 并按照日期建立子目录返回
     *
     * @return
     */
    protected String getSaveFilePath() {

        String path = ROOT_PATH;
        SimpleDateFormat formater = new SimpleDateFormat("yyyyMMdd");
        path = FILE_SEPARATOR + path + FILE_SEPARATOR + formater.format(new Date());

        String staticPath = PathUtil.getStaticPath();

        File dir = new File(staticPath + path);
        //LOG.error(PathUtil.getStaticPath() + path);
        if (!dir.exists()) {
            try {
                boolean isSuccessMakeDir = dir.mkdirs();
                if (!isSuccessMakeDir) {
                    log.error("目录创建失败:" + PathUtil.getStaticPath() + path);
                }
            } catch (Exception e) {
                log.error("目录创建失败" + PathUtil.getStaticPath() + path);
                return "";
            }
        }
        return path;
    }

    /**
     * 依据原始文件名生成新文件名
     *
     * @return
     */
    protected String getTimeStampName() {
        try {
            SecureRandom number = SecureRandom.getInstance("SHA1PRNG");
            return "" + number.nextInt(10000)
                    + System.currentTimeMillis();
        } catch (NoSuchAlgorithmException e) {
            log.error("生成安全随机数失败");
        }
        return ""
                + System.currentTimeMillis();

    }

    public synchronized boolean checkUploadStatus(UploadFile param, File confFile) throws IOException {
        RandomAccessFile confAccessFile = new RandomAccessFile(confFile, "rw");
        //设置文件长度
        confAccessFile.setLength(param.getTotalChunks());
        //设置起始偏移量
        confAccessFile.seek(param.getChunkNumber() - 1);
        //将指定的一个字节写入文件中 127，
        confAccessFile.write(Byte.MAX_VALUE);
        byte[] completeStatusList = FileUtils.readFileToByteArray(confFile);
        confAccessFile.close();//不关闭会造成无法占用
        //创建conf文件文件长度为总分片数，每上传一个分块即向conf文件中写入一个127，那么没上传的位置就是默认的0,已上传的就是127
        for (int i = 0; i < completeStatusList.length; i++) {
            if (completeStatusList[i] != Byte.MAX_VALUE) {
                return false;
            }
        }
        confFile.delete();
        return true;
    }

    protected String getFileName(String fileName){
        if (!fileName.contains(".")) {
            return fileName;
        }
        return fileName.substring(0, fileName.lastIndexOf("."));
    }
}
```

#### 本地上传实现类

创建 `com.shiyanlou.file.operation.upload.product` 包，该包用于存放各种方式上传实现，目前我们暂时只实现本地文件上传方式，在该包下创建 `LocalStorageUploader.java` 文件，并向其中写入如下代码：

```java
package com.shiyanlou.file.operation.upload.product;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.UUID;

import javax.servlet.http.HttpServletRequest;

import com.shiyanlou.file.exception.NotSameFileExpection;
import com.shiyanlou.file.exception.UploadException;
import com.shiyanlou.file.operation.upload.Uploader;
import com.shiyanlou.file.operation.upload.domain.UploadFile;
import com.shiyanlou.file.util.FileUtil;
import com.shiyanlou.file.util.PathUtil;

import org.apache.commons.lang3.StringUtils;
import org.apache.tomcat.util.http.fileupload.servlet.ServletFileUpload;
import org.springframework.stereotype.Component;
import org.springframework.util.DigestUtils;
import org.springframework.web.multipart.MultipartFile;
import org.springframework.web.multipart.support.StandardMultipartHttpServletRequest;

import lombok.extern.slf4j.Slf4j;
import net.coobird.thumbnailator.Thumbnails;

@Component
public class LocalStorageUploader extends Uploader{

    public LocalStorageUploader() {

    }

    @Override
    public List<UploadFile> upload(HttpServletRequest httpServletRequest,UploadFile uploadFile) {
        List<UploadFile> saveUploadFileList = new ArrayList<UploadFile>();
        StandardMultipartHttpServletRequest standardMultipartHttpServletRequest = (StandardMultipartHttpServletRequest) httpServletRequest;
        boolean isMultipart = ServletFileUpload.isMultipartContent(standardMultipartHttpServletRequest);
        if (!isMultipart) {
            throw new UploadException("未包含文件上传域");
        }

        String savePath = getSaveFilePath();

        try {
            Iterator<String> iter = standardMultipartHttpServletRequest.getFileNames();
            while (iter.hasNext()) {
                saveUploadFileList = doUpload(standardMultipartHttpServletRequest, savePath, iter, uploadFile);
            }
        } catch (IOException e) {
            throw new UploadException("未包含文件上传域");
        } catch (NotSameFileExpection notSameFileExpection) {
            notSameFileExpection.printStackTrace();
        }
        return saveUploadFileList;
    }

    private List<UploadFile> doUpload(StandardMultipartHttpServletRequest standardMultipartHttpServletRequest, String savePath, Iterator<String> iter, UploadFile uploadFile) throws IOException, NotSameFileExpection {
        List<UploadFile> saveUploadFileList = new ArrayList<UploadFile>();
        MultipartFile multipartfile = standardMultipartHttpServletRequest.getFile(iter.next());

        String timeStampName = uploadFile.getIdentifier();

        String originalName = multipartfile.getOriginalFilename();

        String fileName = getFileName(originalName);
        String fileType = FileUtil.getFileExtendName(originalName);
        uploadFile.setFileName(fileName);
        uploadFile.setFileType(fileType);
        uploadFile.setTimeStampName(timeStampName);

        String saveFilePath = savePath + FILE_SEPARATOR + timeStampName + "." + fileType;
        String tempFilePath = savePath + FILE_SEPARATOR + timeStampName + "." + fileType + "_tmp";
        String minFilePath = savePath + FILE_SEPARATOR + timeStampName + "_min" + "." + fileType;
        String confFilePath = savePath + FILE_SEPARATOR + timeStampName + "." + "conf";
        File file = new File(PathUtil.getStaticPath() + FILE_SEPARATOR + saveFilePath);
        File tempFile = new File(PathUtil.getStaticPath() + FILE_SEPARATOR + tempFilePath);
        File minFile = new File(PathUtil.getStaticPath() + FILE_SEPARATOR + minFilePath);
        File confFile = new File(PathUtil.getStaticPath() + FILE_SEPARATOR + confFilePath);
        // uploadFile.setIsOSS(0);
        // uploadFile.setStorageType(0);
        uploadFile.setUrl(saveFilePath);

        if (StringUtils.isEmpty(uploadFile.getTaskId())) {
            uploadFile.setTaskId(UUID.randomUUID().toString());
        }

        //第一步 打开将要写入的文件
        RandomAccessFile raf = new RandomAccessFile(tempFile, "rw");
        //第二步 打开通道
        FileChannel fileChannel = raf.getChannel();
        //第三步 计算偏移量
        long position = (uploadFile.getChunkNumber() - 1) * uploadFile.getChunkSize();
        //第四步 获取分片数据
        byte[] fileData = multipartfile.getBytes();
        //第五步 写入数据
        fileChannel.position(position);
        fileChannel.write(ByteBuffer.wrap(fileData));
        fileChannel.force(true);
        fileChannel.close();
        raf.close();
        //判断是否完成文件的传输并进行校验与重命名
        boolean isComplete = checkUploadStatus(uploadFile, confFile);
        if (isComplete) {
            FileInputStream fileInputStream = new FileInputStream(tempFile.getPath());
            String md5 = DigestUtils.md5DigestAsHex(fileInputStream);
            fileInputStream.close();
            if (StringUtils.isNotBlank(md5) && !md5.equals(uploadFile.getIdentifier())) {
                throw new NotSameFileExpection();
            }
            tempFile.renameTo(file);
            if (FileUtil.isImageFile(uploadFile.getFileType())){
                Thumbnails.of(file).size(300, 300).toFile(minFile);
            }

            uploadFile.setSuccess(1);
            uploadFile.setMessage("上传成功");
        } else {
            uploadFile.setSuccess(0);
            uploadFile.setMessage("未完成");
        }
        uploadFile.setFileSize(uploadFile.getTotalSize());
        saveUploadFileList.add(uploadFile);

        return saveUploadFileList;
    }
}
```

#### 本地上传文件实体类

创建 `com.shiyanlou.file.operation.upload.domain` 包，在该包下创建 `UploadFile.java` 文件，并向其中写入如下代码：

```java
package com.shiyanlou.file.operation.upload.domain;

import lombok.Data;

@Data
public class UploadFile {
    private String fileName;
    private String fileType;
    private long fileSize;
    private String timeStampName;
    private int success;
    private String message;
    private String url;
    //切片上传相关参数
    private String taskId;
    private int chunkNumber;
    private long chunkSize;
    private int totalChunks;
    private String identifier;
    private long totalSize;
    private long currentChunkSize;

}
```

### 文件下载

#### 抽象类接口

创建 `com.shiyanlou.file.operation.download` 包，并创建 `Downloader.java` 类，代码如下：

```java
package com.shiyanlou.file.operation.download;

import javax.servlet.http.HttpServletResponse;

import com.shiyanlou.file.operation.download.domain.DownloadFile;

public abstract class Downloader {
    public abstract void download(HttpServletResponse httpServletResponse, DownloadFile uploadFile);
}
```

#### 本地下载实现类

创建 `com.shiyanlou.file.operation.download.product` 包，该包用于存放各种方式下载实现，目前我们暂时只实现本地文件下载方式，并创建 `LocalStorageDownloader.java` 类，代码如下：

```java
package com.shiyanlou.file.operation.download.product;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.OutputStream;

import javax.servlet.http.HttpServletResponse;

import com.shiyanlou.file.operation.download.Downloader;
import com.shiyanlou.file.operation.download.domain.DownloadFile;
import com.shiyanlou.file.util.PathUtil;

import org.springframework.stereotype.Component;

@Component
public class LocalStorageDownloader extends Downloader {
    @Override
    public void download(HttpServletResponse httpServletResponse, DownloadFile downloadFile) {
        BufferedInputStream bis = null;
        byte[] buffer = new byte[1024];
        //设置文件路径
        File file = new File(PathUtil.getStaticPath() + downloadFile.getFileUrl());
        if (file.exists()) {

            FileInputStream fis = null;

            try {
                fis = new FileInputStream(file);
                bis = new BufferedInputStream(fis);
                OutputStream os = httpServletResponse.getOutputStream();
                int i = bis.read(buffer);
                while (i != -1) {
                    os.write(buffer, 0, i);
                    i = bis.read(buffer);
                }

            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                if (bis != null) {
                    try {
                        bis.close();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }
}
```

#### 本地下载文件实体类

创建 `com.shiyanlou.file.operation.download.domain` 包，并创建本地下载文件实体类 `DownloadFile.java`，代码如下：

```java
package com.shiyanlou.file.operation.download.domain;

import lombok.Data;

@Data
public class DownloadFile {
    private String fileUrl;
    private String timeStampName;
}
```

### 文件删除

#### 抽象类接口

创建 `com.shiyanlou.file.operation.delete` 包，并在该包下创建 `Deleter.java` 类，代码如下：

```java
package com.shiyanlou.file.operation.delete;

public abstract class Deleter {
    public abstract void delete(DeleteFile deleteFile);
}
```

#### 本地删除实现类

创建 `com.shiyanlou.file.operation.delete.product` 包，该包用于存放各种方式删除实现，目前我们暂时只实现本地文件删除方式，并在该包下创建 `LocalStorageDeleter.java` 类，代码如下：

```java
package com.shiyanlou.file.operation.delete.product;

import java.io.File;

import com.shiyanlou.file.operation.delete.Deleter;
import com.shiyanlou.file.operation.delete.domain.DeleteFile;
import com.shiyanlou.file.util.FileUtil;
import com.shiyanlou.file.util.PathUtil;

import org.springframework.stereotype.Component;

@Component
public class LocalStorageDeleter extends Deleter {
    @Override
    public void delete(DeleteFile deleteFile) {
        File file = new File(PathUtil.getStaticPath() + deleteFile.getFileUrl());
        if (file.exists()) {
            file.delete();
        }
        
        if (FileUtil.isImageFile(FileUtil.getFileExtendName(deleteFile.getFileUrl()))) {
            File minFile = new File(PathUtil.getStaticPath() + deleteFile.getFileUrl().replace(deleteFile.getTimeStampName(), deleteFile.getTimeStampName() + "_min"));
            if (minFile.exists()) {
                minFile.delete();
            }
        }
    }
}
```

#### 删除文件实体类

创建 `com.shiyanlou.file.operation.delete.domain` 包，并创建删除文件实体类 `DeleteFile.java`，代码如下：

```java
package com.shiyanlou.file.operation.delete.domain;

import lombok.Data;

@Data
public class DeleteFile {
    private String fileUrl;
    private String timeStampName;
}
```

## 创建文件操作工厂

#### 抽象工厂

在 `com.shiyanlou.file.operation` 包下创建类 `FileOperationFactory.java`，代码如下：

```java
package com.shiyanlou.file.operation;

import com.shiyanlou.file.operation.delete.Deleter;
import com.shiyanlou.file.operation.download.Downloader;
import com.shiyanlou.file.operation.upload.Uploader;

public interface FileOperationFactory {
    Uploader getUploader();
    Downloader getDownloader();
    Deleter getDeleter();
}
```

#### 具体工厂

在 `com.shiyanlou.file.operation` 包下创建类 `LocalStorageOperationFactory.java`，代码如下：

```java
package com.shiyanlou.file.operation;

import javax.annotation.Resource;

import com.shiyanlou.file.operation.delete.Deleter;
import com.shiyanlou.file.operation.delete.product.LocalStorageDeleter;
import com.shiyanlou.file.operation.download.Downloader;
import com.shiyanlou.file.operation.download.product.LocalStorageDownloader;
import com.shiyanlou.file.operation.upload.Uploader;
import com.shiyanlou.file.operation.upload.product.LocalStorageUploader;

import org.springframework.stereotype.Component;

@Component
public class LocalStorageOperationFactory implements FileOperationFactory{

    @Resource
    LocalStorageUploader localStorageUploader;
    @Resource
    LocalStorageDownloader localStorageDownloader;
    @Resource
    LocalStorageDeleter localStorageDeleter;
    @Override
    public Uploader getUploader() {
        return localStorageUploader;
    }

    @Override
    public Downloader getDownloader() {
        return localStorageDownloader;
    }

    @Override
    public Deleter getDeleter() {
        return localStorageDeleter;
    }


}
```

## 上传下载接口实现

#### 上传下载文件 DTO

在 `com.shiyanlou.file.dto` 包下创建上传文件 DTO `UploadFileDTO.java`，代码如下：

```java
package com.shiyanlou.file.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import lombok.Data;

@Data
@Schema(name = "上传文件DTO",required = true)
public class UploadFileDTO {

    @Schema(description = "文件路径")
    private String filePath;

    @Schema(description = "上传时间")
    private String uploadTime;

    @Schema(description = "扩展名")
    private String extendName;


    @Schema(description = "文件名")
    private String filename;

    @Schema(description = "文件大小")
    private Long fileSize;

    @Schema(description = "切片数量")
    private int chunkNumber;

    @Schema(description = "切片大小")
    private long chunkSize;

    @Schema(description = "所有切片")
    private int totalChunks;
    @Schema(description = "总大小")
    private long totalSize;
    @Schema(description = "当前切片大小")
    private long currentChunkSize;
    @Schema(description = "md5码")
    private String identifier;

}
```

在 `com.shiyanlou.file.dto` 包下创建下载文件 DTO `DownloadFileDTO.java`，代码如下：

```java
package com.shiyanlou.file.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import lombok.Data;

@Data
@Schema(name = "下载文件DTO",required = true)
public class DownloadFileDTO {
    private Long userFileId;
}
```

#### 上传文件 VO

在 `com.shiyanlou.file.vo` 包下创建上传文件 VO `UploadFileVo.java`，代码如下：

```java
package com.shiyanlou.file.vo;

import java.util.List;

import io.swagger.v3.oas.annotations.media.Schema;
import lombok.Data;

@Data
@Schema(name = "文件上传Vo",required = true)
public class UploadFileVo {

    @Schema(description = "时间戳", example = "123123123123")
    private String timeStampName;
    @Schema(description = "跳过上传", example = "true")
    private boolean skipUpload;
    @Schema(description = "是否需要合并分片", example = "true")
    private boolean needMerge;
    @Schema(description = "已经上传的分片", example = "[1,2,3]")
    private List<Integer> uploaded;


}
```

### 文件上传下载 Service 层代码

#### Service 接口层代码实现

在 `com.shiyanlou.file.service` 包下创建 `FiletransferService.java` 类，代码如下：

```java
package com.shiyanlou.file.service;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.shiyanlou.file.dto.DownloadFileDTO;
import com.shiyanlou.file.dto.UploadFileDTO;

public interface FiletransferService {
    void uploadFile(HttpServletRequest request, UploadFileDTO uploadFileDto, Long userId);
    void downloadFile(HttpServletResponse httpServletResponse, DownloadFileDTO downloadFileDTO);
}
```

#### Service 实现层代码实现

在 `com.shiyanlou.file.service.impl` 包下创建 `FiletransferServiceImpl.java` 类，代码如下：

```java
package com.shiyanlou.file.service.impl;

import java.io.UnsupportedEncodingException;
import java.util.List;

import javax.annotation.Resource;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.shiyanlou.file.dto.DownloadFileDTO;
import com.shiyanlou.file.dto.UploadFileDTO;
import com.shiyanlou.file.mapper.FileMapper;
import com.shiyanlou.file.mapper.UserfileMapper;
import com.shiyanlou.file.model.File;
import com.shiyanlou.file.model.UserFile;
import com.shiyanlou.file.operation.FileOperationFactory;
import com.shiyanlou.file.operation.download.Downloader;
import com.shiyanlou.file.operation.download.domain.DownloadFile;
import com.shiyanlou.file.operation.upload.Uploader;
import com.shiyanlou.file.operation.upload.domain.UploadFile;
import com.shiyanlou.file.service.FiletransferService;
import com.shiyanlou.file.util.DateUtil;
import com.shiyanlou.file.util.PropertiesUtil;

import org.springframework.stereotype.Service;

@Service
public class FiletransferServiceImpl implements FiletransferService{

    @Resource
    FileMapper fileMapper;
    @Resource
    UserfileMapper userfileMapper;

    @Resource
    FileOperationFactory localStorageOperationFactory;

    @Override
    public void uploadFile(HttpServletRequest request, UploadFileDTO uploadFileDto, Long userId) {

        Uploader uploader = null;
        UploadFile uploadFile = new UploadFile();
        uploadFile.setChunkNumber(uploadFileDto.getChunkNumber());
        uploadFile.setChunkSize(uploadFileDto.getChunkSize());
        uploadFile.setTotalChunks(uploadFileDto.getTotalChunks());
        uploadFile.setIdentifier(uploadFileDto.getIdentifier());
        uploadFile.setTotalSize(uploadFileDto.getTotalSize());
        uploadFile.setCurrentChunkSize(uploadFileDto.getCurrentChunkSize());
        String storageType = PropertiesUtil.getProperty("file.storage-type");
        synchronized (FiletransferService.class) {
            if ("0".equals(storageType)) {
                uploader = localStorageOperationFactory.getUploader();
            } 
        }

        List<UploadFile> uploadFileList = uploader.upload(request, uploadFile);
        for (int i = 0; i < uploadFileList.size(); i++){
            uploadFile = uploadFileList.get(i);
            File file = new File();
            
            file.setIdentifier(uploadFileDto.getIdentifier());
            file.setStorageType(Integer.parseInt(storageType));
            file.setTimeStampName(uploadFile.getTimeStampName());
            if (uploadFile.getSuccess() == 1){
                file.setFileUrl(uploadFile.getUrl());
                file.setFileSize(uploadFile.getFileSize());
                file.setPointCount(1);
                fileMapper.insert(file);
                UserFile userFile = new UserFile();
                userFile.setFileId(file.getFileId());
                userFile.setExtendName(uploadFile.getFileType());
                userFile.setFileName(uploadFile.getFileName());
                userFile.setFilePath(uploadFileDto.getFilePath());
                //userFile.setDeleteFlag(0);
                userFile.setUserId(userId);
                userFile.setIsDir(0);
                userFile.setUploadTime(DateUtil.getCurrentTime());
                userfileMapper.insert(userFile);
            }

        }
    }

    @Override
    public void downloadFile(HttpServletResponse httpServletResponse, DownloadFileDTO downloadFileDTO) {
        UserFile userFile = userfileMapper.selectById(downloadFileDTO.getUserFileId());

        String fileName = userFile.getFileName() + "." + userFile.getExtendName();
        try {
            fileName = new String(fileName.getBytes("utf-8"), "ISO-8859-1");
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        }
        httpServletResponse.setContentType("application/force-download");// 设置强制下载不打开
        httpServletResponse.addHeader("Content-Disposition", "attachment;fileName=" + fileName);// 设置文件名


        File file = fileMapper.selectById(userFile.getFileId());
        Downloader downloader = null;
        if (file.getStorageType() == 0) {
            downloader = localStorageOperationFactory.getDownloader();
        }
        DownloadFile uploadFile = new DownloadFile();
        uploadFile.setFileUrl(file.getFileUrl());
        uploadFile.setTimeStampName(file.getTimeStampName());
        downloader.download(httpServletResponse, uploadFile);
    }
}
```

向 `com.shiyanlou.file.model` 包下的 `File.java` 文件中添加下面三个属性，其中：

**storageType** 用来保存文件的存储类型。

**identifier** 保存文件的md5唯一标识，这个唯一标识是文件极速秒传的关键，当检测上传文件的 md5 已存在，则文件已存在于服务器，文件直接返回上传成功。

**pointCount** 用来保存文件的引用数量，当上传文件在服务器已存在，则 pointCount 加1，文件删除的时候减1，此时如果引用数量大于0，则文件逻辑删除，等于0时文件需要彻底物理删除，代码如下：

```java
    @Column(columnDefinition="int(1) comment '存储类型 0-本地存储, 1-阿里云存储, 2-FastDFS存储'")
    private Integer storageType;  

    @Column(columnDefinition="varchar(32) comment 'md5唯一标识'")
    private String identifier;

    @Column(columnDefinition="int(1) comment '引用数量'")
    private Integer pointCount;
```

## 文件传输类接口创建

在 `com.shiyanlou.file.controller` 包下创建 `FiletransferController.java` 类，这个类专门用来作为文件传输接口，主要职责为文件上传，下载及删除，代码如下：

```java
package com.shiyanlou.file.controller;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.annotation.Resource;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import com.shiyanlou.file.dto.DownloadFileDTO;
import com.shiyanlou.file.common.RestResult;
import com.shiyanlou.file.dto.UploadFileDTO;
import com.shiyanlou.file.model.File;
import com.shiyanlou.file.model.User;
import com.shiyanlou.file.model.UserFile;
import com.shiyanlou.file.service.FileService;
import com.shiyanlou.file.service.FiletransferService;
import com.shiyanlou.file.service.UserService;
import com.shiyanlou.file.service.UserfileService;
import com.shiyanlou.file.util.DateUtil;
import com.shiyanlou.file.util.FileUtil;
import com.shiyanlou.file.vo.UploadFileVo;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;

@Tag(name = "filetransfer", description = "该接口为文件传输接口，主要用来做文件的上传和下载")
@RestController
@RequestMapping("/filetransfer")
public class FiletransferController {

    @Resource
    UserService userService;
    @Resource
    FileService fileService;
    @Resource
    UserfileService userfileService;
    @Resource
    FiletransferService filetransferService;

    @Operation(summary = "极速上传", description = "校验文件MD5判断文件是否存在，如果存在直接上传成功并返回skipUpload=true，如果不存在返回skipUpload=false需要再次调用该接口的POST方法", tags = {"filetransfer"})
    @GetMapping(value = "/uploadfile")
    @ResponseBody
    public RestResult<UploadFileVo> uploadFileSpeed(UploadFileDTO uploadFileDto, @RequestHeader("token") String token) {

        User sessionUser = userService.getUserByToken(token);
        if (sessionUser == null){

            return RestResult.fail().message("未登录");
        }

        UploadFileVo uploadFileVo = new UploadFileVo();
        Map<String, Object> param = new HashMap<String, Object>();
        param.put("identifier", uploadFileDto.getIdentifier());
        synchronized (FiletransferController.class) {
            List<File> list = fileService.listByMap(param);
            if (list != null && !list.isEmpty()) {
                File file = list.get(0);

                UserFile userfile = new UserFile();
                userfile.setFileId(file.getFileId());
                userfile.setUserId(sessionUser.getUserId());
                userfile.setFilePath(uploadFileDto.getFilePath());
                String fileName = uploadFileDto.getFilename();
                userfile.setFileName(fileName.substring(0, fileName.lastIndexOf(".")));
                userfile.setExtendName(FileUtil.getFileExtendName(fileName));
                userfile.setIsDir(0);
                userfile.setUploadTime(DateUtil.getCurrentTime());
                userfileService.save(userfile);
                // fileService.increaseFilePointCount(file.getFileId());
                uploadFileVo.setSkipUpload(true);

            } else {
                uploadFileVo.setSkipUpload(false);

            }
        }
        return RestResult.success().data(uploadFileVo);

    }

    @Operation(summary = "上传文件", description = "真正的上传文件接口", tags = {"filetransfer"})
    @RequestMapping(value = "/uploadfile", method = RequestMethod.POST)
    @ResponseBody
    public RestResult<UploadFileVo> uploadFile(HttpServletRequest request, UploadFileDTO uploadFileDto, @RequestHeader("token") String token) {

        User sessionUser = userService.getUserByToken(token);
        if (sessionUser == null){
            return RestResult.fail().message("未登录");
        }


        filetransferService.uploadFile(request, uploadFileDto, sessionUser.getUserId());
        UploadFileVo uploadFileVo = new UploadFileVo();
        return RestResult.success().data(uploadFileVo);

    }

    @Operation(summary = "下载文件", description = "下载文件接口", tags = {"filetransfer"})
    @RequestMapping(value = "/downloadfile", method = RequestMethod.GET)
    public void downloadFile(HttpServletResponse response, DownloadFileDTO downloadFileDTO) {
        filetransferService.downloadFile(response, downloadFileDTO);
    }
}
```

## 实验总结

由于上传下载文件接口的特殊性，本节实验暂时不对接口进行测试，等到后面进行前后端联调的时候去对文件上传下载功能做一个系统性的测试，另外在编写代码的时候，不能只以实现功能为目标，更要考虑以后的扩展性。

本次实验完整代码可以通过如下命令进行下载：

```bash
wget https://labfile.oss.aliyuncs.com/courses/8842/code8.zip
```