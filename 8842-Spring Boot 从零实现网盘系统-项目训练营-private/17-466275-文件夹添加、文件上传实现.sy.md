---
show: step
version: 1.0
enable_checker: true
---

# 文件夹添加、文件上传实现

## 实验介绍

本实验将介绍文件夹的添加和文件上传，包括文件秒传、对大文件的文件切片和断点上传功能的实现，之后将会完善文件列表数据展示，并添加存储空间统计。

#### 知识点

- 文件切片
- 断点上传
- 文件秒传
- 全局函数
- Element UI 的 Dialog 对话框和 Progress 进度条组件的使用

#### 开发计划

- 开发内容：
  1. 使用 Dialog 组件实现新建文件夹功能
  2. 使用开源插件 [vue-simple-uploader](https://github.com/simple-uploader/vue-uploader) 实现文件上传：包括文件秒传、大文件切片和断点上传
  3. 完善文件列表数据展示：文件图标、文件扩展名
  4. 在左侧文件分类栏底部，添加存储空间大小展示。
- 开发耗时：实验预计完成时间为 2~3 小时
- 开发难点：vue-simple-uploader 开源插件的使用

## 添加文件上传组件

在 `src/views/Home/components` 下创建文件 `OperationMenu.vue`，将文件夹的添加、文件上传均放在此组件中，文件内容稍后讲解。在 `src/views/Home/index.vue` 中引入此文件，将 fileType 传递给子组件，以便在不同类型文件页面，判断是否对新建文件夹按钮做禁用：

```vue
<template>
  <div class="home">
    <!-- 左侧菜单 - 区分文件类型 -->
    <SideMenu class="home-left"></SideMenu>
    <!-- 右侧内容区 -->
    <div class="home-right">
      <div class="operation-wrapper">
        <!-- 3. 使用组件 -->
        <OperationMenu :fileType="fileType"></OperationMenu>
        <SelectColumn></SelectColumn>
      </div>
      <!-- 已有代码不再赘述 -->
      //删除原有的 <SelectColumn></SelectColumn>
      ...
    </div>
  </div>
</template>

<script>
...
import OperationMenu from './components/OperationMenu.vue' //  1.引入文件上传组件

export default {
  name: 'Home',
  components: {
    ...
    OperationMenu // 2. 注册组件
  },
  ...
</script>

<style lang="stylus" scoped>
.home {
  .home-right {
    // 已有代码不再赘述
    ...
    .operation-wrapper {
      margin-bottom: 16px;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
  }
}
</style>
```

对所有跳转到首页中**全部**类型文件页面的路由做修改：

`src/components/Header.vue` 中跳转到首页的路由修改为：

```vue
<el-menu-item index="Home" :route="{ name: 'Home', query: { fileType: 0, filePath: '/' } }">首页</el-menu-item>
```

`src/views/Home/components/SideMenu.vue` 中跳转到首页的路由修改为：

```vue
<el-menu-item index="0" :route="{ name: 'Home', query: { fileType: 0, filePath: '/' } }">
    <i class="el-icon-menu"></i>
    <span slot="title">全部</span>
</el-menu-item>
```

`Login.vue` 和 `Register.vue` 中跳转到首页的路由修改为：

```javascript
this.$router.replace({
  name: 'Home',
  query: { fileType: 0, filePath: '/' }
})
```

同时将 `SideMenu.vue` 中 `created()` 中的路由跳转代码删除：

![14-1](https://doc.shiyanlou.com/courses/3472/1557563/c618202b0c4b29585d579f3cd8142961-0/wm)

现在退出登录，重新登录，跳转到首页的路由参数会带上 fileType 和 filePath。

## 新建文件夹功能

在 `src/views/Home/index.vue` 中将 filePath 传递给子组件，同时接收子组件向外触发的获取文件列表事件：

```vue
<OperationMenu :fileType="fileType" :filePath="filePath" @getTableData="getFileData"></OperationMenu>
```

filePath 的值通过路由参数获取：

```javascript
computed: {
    ...
    // 当前所在路径
    filePath() {
    	return this.$route.query.filePath
    }
},
```

在 `src/request/file.js` 中添加新建文件夹接口：

```javascript
import { get, post } from './http'

// 创建文件夹 或 文件
export const createFile = (p) => post('/file/createfile', p)
```

在 `OperationMenu.vue` 中使用按钮组来包裹新建文件按钮，点击按钮弹出对话框，用户输入文件夹名称，点击对话框提交按钮，表单校验通过后，调用新建文件夹接口，创建成功后，关闭对话框，并重新获取文件列表：

```vue
<template>
  <div class="operation-menu-wrapper">
    <!-- 按钮组 -->
    <el-button-group class="operate-group">
      <!-- disabled 只在全部类型页面 才可新建文件夹 -->
      <el-button
        size="mini"
        type="primary"
        icon="el-icon-plus"
        :disabled="fileType !== 0"
        @click="addFolderDialog.visible = true"
        >新建文件夹</el-button
      >
    </el-button-group>

    <!-- 对话框 - 新建文件夹 -->
    <!-- @closed 对话框关闭动画结束时 重置表单并清空所有表单校验 -->
    <el-dialog
      title="新建文件夹"
      width="600px"
      :visible.sync="addFolderDialog.visible"
      @closed="$refs.addFolderForm.resetFields()"
    >
      <el-form :model="addFolderForm" :rules="addFolderRules" label-position="top" ref="addFolderForm">
        <el-form-item label="文件夹名称" prop="name">
          <el-input v-model="addFolderForm.name"></el-input>
        </el-form-item>
      </el-form>
      <span slot="footer" class="dialog-footer">
        <el-button @click="addFolderDialog.visible = false">取 消</el-button>
        <el-button type="primary" :loading="addFolderDialog.loading" @click="handleAddFolderSubmit('addFolderForm')"
          >提 交</el-button
        >
      </span>
    </el-dialog>
  </div>
</template>

<script>
import { createFile } from '@/request/file.js'

export default {
  name: 'OperationMenu',
  props: {
    // 文件类型
    fileType: {
      type: Number,
      required: true
    },
    // 文件路径
    filePath: {
      type: String,
      required: true
    }
  },
  data() {
    return {
      // 新建文件夹对话框数据
      addFolderDialog: {
        visible: false, //  对话框显隐状态
        loading: false
      },
      // 新建文件夹表单
      addFolderForm: {
        name: ''
      },
      // 新建文件夹表单校验规则
      addFolderRules: {
        name: [
          {
            required: true,
            message: '请输入文件夹名称',
            trigger: 'blur, change'
          }
        ]
      }
    }
  },
  methods: {
    // 新建文件夹对话框 - 提交按钮
    handleAddFolderSubmit(formName) {
      this.$refs[formName].validate((valid) => {
        if (valid) {
          this.addFolderDialog.loading = true //  对话框的确定按钮打开loading状态
          // 表单校验通过 - 调用新建文件夹接口
          createFile({
            fileName: this.addFolderForm.name,
            filePath: this.filePath, //  文件路径
            isDir: 1 //  是否为文件夹：1 表示文件夹 0 表示文件
          }).then(
            (res) => {
              this.addFolderDialog.loading = false //  对话框的确定按钮关闭loading状态
              if (res.success) {
                this.$message.success('添加成功')
                this.addFolderDialog.visible = false //  关闭对话框
                this.$emit('getTableData') // 重新获取文件列表
              } else {
                this.$message.warning(res.message)
              }
            },
            (error) => {
              this.addFolderDialog.loading = false //  对话框的确定按钮关闭loading状态
              console.log(error)
            }
          )
        } else {
          return false
        }
      })
    }
  }
}
</script>
```

刷新首页，新建文件夹“实验楼”：

<img src="https://doc.shiyanlou.com/courses/3472/1557563/b63eca1b6131a030ef52c67face2ecad-0/wm" alt="14-2" style="zoom:67%;" />

面包屑导航栏文件 `BreadCrumb.vue` 也需要一些改造：

```vue
<script>
export default {
  name: 'BreadCrumb',
  ...
  computed: {
    // 依据路径查看时 当前路径拆分的面包屑数据，data 中原有的 breadCrumbList 需要删掉
    breadCrumbList() {
      let path = this.$route.query.filePath //  路径示例 /实验楼/
      let pathList = path ? path.split('/').slice(1, -1) : [] // 路径列表，取第二个 ~ 倒数第二个，因为第一个和最后一个数组项都是空字符串
      let res = [{ name: '全部文件', path: '/' }]
      pathList.forEach((element, index) => {
        res.push({
          name: element,
          path: `${res[index].path}${element}/`
        })
      })
      return res
    }
  }
}
</script>
...
```

根据路径获取文件列表接口 getFileListByPath 中的请求参数 filePath 也需要改为路由参数中的 filePath，监听路由参数中的 filePath 变化，值改变时，重新获取文件列表。这样点击面包屑导航栏中的某一级就可以获取该路径下的文件列表了。在 `src/views/Home/index.vue` 中修改：

```javascript
...
watch: {
    filePath() {
      // 当左侧菜单选择全部，文件路径发生变化时，再重新获取文件列表
      if (this.fileType === 0) {
        this.getFileData() //  获取文件列表
      }
    }
},
methods: {
    ...
    // 根据路径获取文件列表
    getFileDataByPath() {
        getFileListByPath({
            filePath: this.filePath, // 传递当前路径
            currentPage: this.pageData.currentPage,
            pageCount: this.pageData.pageCount
        }).then(
            // 已有代码不再赘述
            ...
        )
    }
}
```

## 文件列表数据处理

现在获取文件列表接口的返回值有值了，来处理下这些返回值，以便能更好的在表格中展示：

1. 类型：显示当前行的文件类型，若为文件夹就显示“文件夹”；
2. 大小：显示当前行的文件的大小，单位转化为 KB、MB、GB；
3. 文件名：当前行若为文件夹，点击文件名，进入文件夹内部，获取文件夹内部的文件列表，路由参数中的 filePath 和面包屑导航栏随之改变，表格数据重新渲染。

在 `FileTable.vue` 中加入以下内容，处理文件类型：

```vue
...
<el-table-column 
    prop="extendName"
    label="类型"
    width="100"
    v-if="selectedColumnList.includes('extendName')"
    >
    <template slot-scope="scope">
        <span>{{ scope.row.extendName ? scope.row.extendName : '文件夹' }}</span>
    </template>
</el-table-column>
...
```

处理文件大小：

```vue
...
<el-table-column
    prop="fileSize"
    label="大小"
    width="100"
    v-if="selectedColumnList.includes('fileSize')"
    >
    <template slot-scope="scope">
		  <span>{{ calculateFileSize(scope.row.fileSize) }}</span>
    </template>
</el-table-column>
...
```

处理函数如下：

```javascript
...
  methods: {
    //  计算文件大小
    calculateFileSize(size) {
        const B = 1024
        const KB = Math.pow(1024, 2)
        const MB = Math.pow(1024, 3)
        const GB = Math.pow(1024, 4)
        if (!size) {
            return '_'
        } else if (size < KB) {
            return (size / B).toFixed(0) + 'KB'
        } else if (size < MB) {
            return (size / KB).toFixed(1) + 'MB'
        } else if (size < GB) {
            return (size / MB).toFixed(2) + 'GB'
        } else {
            return (size / GB).toFixed(3) + 'TB'
        }
    },
    // 删除按钮 - 点击事件
    handleClickDelete(row) {
      console.log('删除', row.fileName)
    },
    ...
```

处理文件名点击事件：

```vue
<el-table-column prop="fileName" label="文件名">
    <template slot-scope="scope">
        <div style="cursor: pointer" @click="handleFileNameClick(scope.row)">
        	{{ scope.row.fileName }}
        </div>
    </template>
</el-table-column>
```

添加函数：

```javascript
methods: {
    // 文件名点击事件
    handleFileNameClick(row) {
        //  若是目录则进入目录
        if (row.isDir) {
            this.$router.push({
                query: {
                    filePath: `${row.filePath}${row.fileName}/`,
                    fileType: 0
                }
            })
        }
    },
    ...
}
```

刷新首页，点击文件夹名称路由参数改变，可以进入到文件夹内部查看文件列表，点击面包屑导航栏也可以切换文件查看路径：

<img src="https://doc.shiyanlou.com/courses/3472/1557563/6d4d737a69746daab022b0f2e4f942e0-0/wm" alt="14-3" style="zoom:67%;" />

再来调整下表格高度和滚动条样式，使表格高度自适应窗口高度，表格组件添加 height 属性，继续编辑 `FileTable.vue` 文件：

```vue
<template>
  <el-table 
    class="file-table" 
    :data="tableData" 
    height="calc(100vh - 202px)" 
    style="width: 100%" 
    v-loading="loading"
  >
  ...
```

```stylus
<style lang="stylus" scoped>
.file-table {
  // 调整滚动条样式
  >>> .el-table__body-wrapper {
    setScrollbar(8px, #EBEEF5, #909399);
  }
}
...
</style>
```

刷新首页，可以看到表格已经可以自适应高度了：

![14-4](https://doc.shiyanlou.com/courses/3472/1557563/6ffbf090ddf9bdeeaa14f34c504dfada-0/wm)

## 文件上传功能

大多数项目，文件上传可以使用 Element UI 自带的 Upload 组件来实现，但是对于一个文件管理系统来说，要支撑大文件上传，需要使用文件切片，断点续传等技术。

目前有许多优秀的开源插件可以实现此类技术，这里就不再重复造轮子。此次实验使用了开源插件 [vue-simple-uploader](https://github.com/simple-uploader/vue-uploader) 来封装文件上传组件，此插件具有文件秒传、切片上传、断点续传的功能，具体参数说明可以去 Github 上查看；同时使用计算文件 MD5 的方式，来让后台判断是否有相同文件已存在于服务器中。

先来安装插件 `vue-simple-uploader`：

```bash
npm install vue-simple-uploader --save
```

安装 `spark-md5` 用于计算文件 MD5：

```bash
npm install spark-md5 --save
```

在 `main.js` 中引入：

```javascript
import Vue from 'vue'
import uploader from 'vue-simple-uploader'
...

Vue.use(uploader)
```

在 `src/views/Home/components` 中创建上传文件组件 `FileUploader.vue`，在 `src/views/Home/index.vue` 中引入：

```vue
<template>
  <div class="home">
    <!-- 已有代码不再赘述 -->
    ...
    <!-- 3. 使用文件上传组件 -->
    <FileUploader ref="globalUploader"></FileUploader>
  </div>
</template>

<script>
...
import FileUploader from './components/FileUploader.vue' //  1. 引入文件上传组件

export default {
  components: {
    ...
    FileUploader //  2. 注册文件上传组件
  },
  ...
}
</script>
```

### 整体流程概览

1. 点击上传文件按钮，触发文件上传操作，展示文件上传窗口。
   在 `OperationMenu.vue` 中添加上传文件按钮：

   ```vue
   <template>
     <div class="operation-menu-wrapper">
       <!-- 按钮组 -->
       <el-button-group class="operate-group">
         <!-- 已有代码不再赘述 -->
         ...
         <el-button
           size="mini"
           type="primary"
           icon="el-icon-upload2"
           @click="handleUploadFileClick()"
           :disabled="fileType !== 0"
           >上传文件</el-button
         >
       </el-button-group>
       ...
     </div>
   </template>

   <script>
   export default {
     name: 'OperationMenu',
     ...
     methods: {
       ...
       // 上传文件按钮 - 点击事件
       handleUploadFileClick() {
         this.$emit('handleUploadFile', true)
       }
     }
   }
   </script>
   ```

   在 `src/views/Home/index.vue` 中将接收上传文件按钮点击事件，打开上传文件窗口：

   ```vue
   <!-- 操作按钮组件 -->
   <OperationMenu
     :fileType="fileType"
     :filePath="filePath"
     @getTableData="getFileData"
     @handleUploadFile="handleUploadFile"
   ></OperationMenu>
   ```

   ```vue
   <!-- 文件上传组件 -->
   <FileUploader ref="globalUploader" @getTableData="getFileData"></FileUploader>
   ```

   ```javascript
   // 上传文件 按钮点击事件
   handleUploadFile() {
       //  触发子组件中的打开文件上传窗口事件
   	this.$refs.globalUploader.triggerSelectFileClick()
   }
   ```

   在 `FileUploader.vue` 中添加打开文件上传窗口事件：

   ```javascript
   // 触发选择文件按钮的点击事件
   triggerSelectFileClick() {
   	this.$refs.uploadBtn.$el.click() // 触发 选择文件按钮 的点击事件
   },
   ```

2. 开始计算文件 MD5，这里需要将组件的 `autoStart` 设为 false，关闭自动上传功能。

3. 计算完毕，开始文件分片上传。

4. 上传过程中，会不断触发组件 `file-progress` 上传进度的回调，可以将上传进度打印出来，在控制台查看上传进度。

5. 文件上传成功后，在 `file-success` 的回调中，刷新文件列表。

### 文件切片

`vue-simple-uploader` 自动将文件进行分片，在 `options` 的 `chunkSize` 中可以设置每个分片的大小。对于大文件来说，会发送多个请求，在设置 `testChunks` 为 `true` 后（在插件中默认就是`true`），会发送与服务器进行分片校验的请求。

看一下发送给服务端的参数，其中 `chunkNumber` 表示当前是第几个分片，`totalChunks` 代表所有的分片数，这两个参数都是插件根据你设置的 `chunkSize` 来计算的。

`skipUpload` 表示当前分片已存在于服务器中，无需上传此分片了。

此时 `FileUploader.vue` 文件的内容如下所示：

```vue
<template>
  <div id="global-uploader">
    <!-- 上传组件 -->
    <uploader
      class="uploader-box"
      ref="uploader"
      :options="options"
      :autoStart="false"
      @file-added="handleFileAdded"
      @file-progress="onFileProgress"
      @file-success="handleFileSuccess"
      @file-error="handleFileError"
    >
      <uploader-unsupport></uploader-unsupport>
      <!-- 选择文件按钮 -->
      <uploader-btn class="select-file-btn" :attrs="attrs" ref="uploadBtn">选择文件</uploader-btn>
      <!-- 正在上传的文件面板 -->
      <uploader-list v-show="panelShow">
        <div class="file-panel" slot-scope="props">
          <div class="panel-title">
            <span class="text">上传列表</span>
            <div class="operate-btn-wrapper">
              <el-button type="text" title="关闭窗口" icon="el-icon-close" @click="handleClosePanel"> </el-button>
            </div>
          </div>
          <!-- 正在上传的文件列表 -->
          <ul class="file-list">
            <li class="file-item" v-for="file in props.fileList" :key="file.id">
              <uploader-file ref="files" :class="`file_${file.id}`" :file="file" :list="true"></uploader-file>
            </li>
            <div class="no-file" v-if="!props.fileList.length"><i class="icon-empty-file"></i> 暂无待上传文件</div>
          </ul>
        </div>
      </uploader-list>
    </uploader>
  </div>
</template>

<script>
import SparkMD5 from 'spark-md5'
import Cookies from 'js-cookie'

export default {
  name: 'FileUploader',
  data() {
    return {
      // 上传组件配置项，详细说明 https://github.com/simple-uploader/Uploader/blob/develop/README_zh-CN.md#uploader
      options: {
        target: 'api/filetransfer/uploadfile', // 目标上传 URL
        chunkSize: 1024 * 1024, //  每个分片的大小
        fileParameterName: 'file', //  上传文件时文件的参数名，默认 file
        maxChunkRetries: 3, //  并发上传数，默认 3
        testChunks: true, //  是否开启分片已存在于服务器的校验
        // 服务器分片校验函数，秒传及断点续传基础
        checkChunkUploadedByResponse: function (chunk, message) {
          let data = JSON.parse(message).data
          if (data.skipUpload) {
            // 分片已存在于服务器中
            return true
          }
          return (data.uploaded || []).indexOf(chunk.offset + 1) >= 0
        },
        headers: {
          token: Cookies.get('token')
        },
        query() {}
      },
      attrs: {
        accept: '*' // 可接受的文件类型
      },
      panelShow: false //  上传文件面板是否显示
    }
  }
}
</script>
```

### 文件秒传及断点续传

整体思路如下：

1. 通过 `file.pause()` 暂停文件上传。
2. 使用 `spark-md5` 计算文件 MD5 值。
3. file 有个属性是 `uniqueIdentifier`，代表文件唯一标识，把计算出来的 MD5 赋值给这个属性。
4. 服务器判断逻辑如下：

   - 服务器发现文件已经完全上传成功，则直接返回**文件秒传**的标识。
   - 服务器发现文件上传过分片信息，则返回这些分片信息，告诉前端继续上传，即**断点续传**，前端通过 `file.resume()` 继续上传文件。
   - 服务器发现不存在此文件的分片信息，那这就是个全新的文件了，走完整的分片上传逻辑，前端通过 `file.resume()` 开始上传文件。

最后 `FileUploader.vue` 文件的完整代码如下：

```vue
<template>
  <div id="global-uploader">
    <!-- 上传组件 -->
    <uploader
      class="uploader-box"
      ref="uploader"
      :options="options"
      :autoStart="false"
      @file-added="handleFileAdded"
      @file-progress="onFileProgress"
      @file-success="handleFileSuccess"
      @file-error="handleFileError"
    >
      <uploader-unsupport></uploader-unsupport>
      <!-- 选择文件按钮 -->
      <uploader-btn class="select-file-btn" :attrs="attrs" ref="uploadBtn">选择文件</uploader-btn>
      <!-- 正在上传的文件面板 -->
      <uploader-list v-show="panelShow">
        <div class="file-panel" slot-scope="props">
          <div class="panel-title">
            <span class="text">上传列表</span>
            <div class="operate-btn-wrapper">
              <el-button type="text" title="关闭窗口" icon="el-icon-close" @click="handleClosePanel"> </el-button>
            </div>
          </div>
          <!-- 正在上传的文件列表 -->
          <ul class="file-list">
            <li class="file-item" v-for="file in props.fileList" :key="file.id">
              <uploader-file ref="files" :class="`file_${file.id}`" :file="file" :list="true"></uploader-file>
            </li>
            <div class="no-file" v-if="!props.fileList.length"><i class="icon-empty-file"></i> 暂无待上传文件</div>
          </ul>
        </div>
      </uploader-list>
    </uploader>
  </div>
</template>

<script>
import SparkMD5 from 'spark-md5'
import Cookies from 'js-cookie'

export default {
  name: 'FileUploader',
  data() {
    return {
      // 上传组件配置项，详细说明 https://github.com/simple-uploader/Uploader/blob/develop/README_zh-CN.md#uploader
      options: {
        target: 'api/filetransfer/uploadfile', // 目标上传 URL
        chunkSize: 1024 * 1024, //  每个分片的大小
        fileParameterName: 'file', //  上传文件时文件的参数名，默认 file
        maxChunkRetries: 3, //  并发上传数，默认 3
        testChunks: true, //  是否开启分片已存在于服务器的校验
        // 服务器分片校验函数，秒传及断点续传基础
        checkChunkUploadedByResponse: function (chunk, message) {
          let data = JSON.parse(message).data
          if (data.skipUpload) {
            // 分片已存在于服务器中
            return true
          }
          return (data.uploaded || []).indexOf(chunk.offset + 1) >= 0
        },
        headers: {
          token: Cookies.get('token')
        },
        query() {}
      },
      attrs: {
        accept: '*' // 可接受的文件类型
      },
      panelShow: false //  上传文件面板是否显示
    }
  },
  computed: {
    // 全局上传组件 uploader实例
    uploader() {
      return this.$refs.uploader.uploader
    },
    // 当前所在路径
    filePath() {
      return this.$route.query.filePath ? this.$route.query.filePath : '/'
    },
    // 是否触发上传文件事件
    startUploadFile() {
      return this.$store.state.file.startUploadFile
    }
  },
  methods: {
    // 触发选择文件按钮的点击事件
    triggerSelectFileClick() {
      this.$refs.uploadBtn.$el.click() // 触发 选择文件按钮 的点击事件
    },
    // 文件添加 回调函数
    handleFileAdded(file) {
      this.panelShow = true //  显示文件上传面板
      this.calculateFileMD5(file) //  计算文件MD5值
    },
    /**
     * 文件上传过程 回调函数
     * @param rootFile 成功上传的文件所属的根 Uploader.File 对象，它应该包含或者等于成功上传文件
     * @param file 当前成功的 Uploader.File 对象本身
     * @param chunk Uploader.Chunk 实例，它就是该文件的最后一个块实例，如果你想得到请求响应码的话，chunk.xhr.status 就是
     */
    onFileProgress(rootFile, file, chunk) {
      // 打印文件上传过程中的信息
      console.log(`上传中 ${file.name}，chunk：${chunk.startByte / 1024 / 1024} ~ ${chunk.endByte / 1024 / 1024}`)
    },
    /**
     * 文件上传成功 回调函数
     * @param responseStr 服务端响应内容，永远都是字符串
     */
    handleFileSuccess(rootFile, file, responseStr) {
      let response = JSON.parse(responseStr)
      if (response.success) {
        this.$message.success(`${file.name} - 上传完毕`)
        this.$emit('getTableData') //  刷新文件列表
      } else {
        this.$message.error(response.message)
      }
    },
    // 文件上传失败 回调函数
    handleFileError(rootFile, file, responseStr) {
      this.$message({
        message: JSON.parse(responseStr).message,
        type: 'error'
      })
    },
    // 计算文件MD5值，实现断点续传及秒传
    calculateFileMD5(file) {
      let fileReader = new FileReader()
      let time = new Date().getTime()
      let blobSlice = File.prototype.slice || File.prototype.mozSlice || File.prototype.webkitSlice
      let currentChunk = 0
      const chunkSize = 1 * 1024 * 1024
      let chunks = Math.ceil(file.size / chunkSize)
      let spark = new SparkMD5.ArrayBuffer()
      file.pause() //  暂停上传文件
      loadNext()
      fileReader.onload = (e) => {
        spark.append(e.target.result)
        if (currentChunk < chunks) {
          currentChunk++
          loadNext()
        } else {
          let md5 = spark.end()
          this.calculateFileMD5End(md5, file)
          console.log(
            `MD5计算完毕：${file.name} \nMD5：${md5} \n分片：${chunks} 大小:${file.size} 用时：${
              new Date().getTime() - time
            } ms`
          )
        }
      }
      fileReader.onerror = function () {
        this.$notify({
          title: '上传出错',
          message: `文件${file.name}读取出错，请检查该文件`,
          type: 'error',
          duration: 2000
        })
        file.cancel() //  取消上传且从文件列表中移除。
      }
      function loadNext() {
        let start = currentChunk * chunkSize
        let end = start + chunkSize >= file.size ? file.size : start + chunkSize
        fileReader.readAsArrayBuffer(blobSlice.call(file.file, start, end))
      }
    },
    // 文件MD5计算结束
    calculateFileMD5End(md5, file) {
      // 将自定义参数直接加载uploader实例的opts上
      Object.assign(this.uploader.opts, {
        query: {
          filePath: this.filePath,
          isDir: 0 // isDir 为 0 表示上传的是文件
        }
      })
      file.uniqueIdentifier = md5
      file.resume() //  继续上传文件
    },
    // 关闭上传面板
    handleClosePanel() {
      this.uploader.cancel() //  取消上传文件
      this.panelShow = false
    }
  }
}
</script>

<style lang="stylus" scoped>
#global-uploader {
  position: fixed;
  z-index: 20;
  right: 15px;
  bottom: 15px;

  .uploader-box {
    width: 520px;
  }

  .file-panel {
    background-color: #fff;
    border: 1px solid #e2e2e2;
    border-radius: 7px 7px 0 0;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);

    .panel-title {
      display: flex;
      height: 40px;
      line-height: 40px;
      padding: 0 16px;
      border-bottom: 1px solid #ddd;

      .text {
        padding-left: 0;
        margin-bottom: 0;
        font-size: 16px;
        color: #303133;
      }

      .operate-btn-wrapper {
        flex: 1;
        text-align: right;

        >>> .el-button {
          *:hover {
            opacity: 0.5;
          }

          i[class^=el-icon-] {
            color: #000;
          }
        }
      }
    }

    .file-list {
      position: relative;
      height: 240px;
      overflow-x: hidden;
      overflow-y: auto;
      background-color: #fff;
      font-size: 14px;

      .file-item {
        background-color: #fff;

        >>>.uploader-file-icon {
          display: none;
        }
      }
    }
  }

  .no-file {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 16px;
  }

  /deep/.uploader-file-actions > span {
    margin-right: 6px;
  }
}

/* 隐藏上传按钮 */
.select-file-btn {
  display: none;
}
</style>
```

`vue-simple-uploader` 基于 `simple-uploader.js` 开发，示例代码中所有的回调函数及配置项，都可参考 [simple-uploader.js](https://github.com/simple-uploader/Uploader/blob/develop/README_zh-CN.md#uploader)，大家可以自己尝试。

刷新首页，测试下文件上传功能：

<img src="https://doc.shiyanlou.com/courses/3472/1557563/89715bcb10eef5ede9278154998bb789-0/wm" alt="14-5" style="zoom: 67%;" />

## 完善文件列表数据回显

文件夹的添加和文件的上传功能介绍完毕了，来完善下我们的表格数据回显：

1. 在文件名称列之前，添加上对应类型的图标，可以去[iconfont](https://www.iconfont.cn/home/index)上寻找文件类型图标库，下载为 png 或 svg 格式使用，当图标过多时，可以使用更为常用的 Font class 或 Unicode 方式。为了简便，这里使用 png 格式。
2. 文件名后拼接扩展名。

### 文件图标资源上传

本地环境大家可以直接下载并保存到项目的 `src/assets/images` 中，我们看一下环境中如何操作。

在环境中执行如下命令：

```bash
cd /home/project/file-web/src/assets
wget https://labfile.oss.aliyuncs.com/courses/3472/image.zip
unzip image.zip
```

![14-8](https://doc.shiyanlou.com/courses/3472/1557563/ea31b71c8c2f62995a9368d2b9731cf3-0/wm)

### 全局函数-回显图片缩略图

在 `src` 下新建文件夹 `libs`，并新建文件 `globalFunction.js`，写入以下内容：

```javascript
//全局函数 ，挂载到Vue实例上
export default function install(Vue) {
  //  加载缩略图
  Vue.prototype.downloadImgMin = function (row) {
    let fileUrl = row.fileUrl
    if (fileUrl) {
      let index = fileUrl.lastIndexOf(".");
      fileUrl = "api" + fileUrl.substr(0, index) + "_min" + fileUrl.substr(index);
    }
    return fileUrl
  };
  // 当然，你还可以在这里封装并挂载更多的全局函数在这里，示例同上
}
```

在 `src/main.js` 中将全局函数挂载在 Vue 实例上：

```javascript
...
import all from '@/libs/globalFunction.js'

...
Vue.use(all)
```

### 其他文件类型图标回显

结合文件扩展名，来对常用的文件类型添加图标，同时在文件名列，拼接上文件扩展名，修改 `FileTable.vue` 文件：

```vue
<template>
  <el-table class="file-table" :data="tableData" height="calc(100vh - 202px)" style="width: 100%" v-loading="loading">
    <el-table-column label prop="isDir" width="60" align="center">
      <template slot-scope="scope">
        <img :src="setFileImg(scope.row)" style="width: 30px" />
      </template>
    </el-table-column>
    <el-table-column prop="fileName" label="文件名">
      <template slot-scope="scope">
        <div style="cursor: pointer" @click="handleFileNameClick(scope.row)">
          {{
            scope.row.extendName
              ? `${scope.row.fileName}.${scope.row.extendName}`
              : `${scope.row.fileName}`
          }}
        </div>
      </template>
    </el-table-column>
    <!-- 已有代码不再赘述 -->
    ...
  </el-table>
</template>

<script>
export default {
  name: 'FileTable',
  ...
  data() {
    return {
      //  文件图片Map映射
      fileImgMap: {
        apk: require('@/assets/image/apk.png'),
        csv: require('@/assets/image/csv.png'),
        doc: require('@/assets/image/doc.png'),
        excel: require('@/assets/image/excel.png'),
        exe: require('@/assets/image/exe.png'),
        fold: require('@/assets/image/fold.png'),
        gif: require('@/assets/image/gif.png'),
        html: require('@/assets/image/html.png'),
        json: require('@/assets/image/json.png'),
        mp3: require('@/assets/image/mp3.png'),
        mp4: require('@/assets/image/mp4.png'),
        other: require('@/assets/image/other.png'),
        pdf: require('@/assets/image/pdf.png'),
        ppt: require('@/assets/image/ppt.png'),
        rar: require('@/assets/image/rar.png'),
        svg: require('@/assets/image/svg.png'),
        txt: require('@/assets/image/txt.png'),
        zip: require('@/assets/image/zip.png')
      }
    }
  },
  ...
  methods: {
    //  根据文件扩展名设置文件图片
    setFileImg(row) {
      if (!row.extendName) {
        //  文件夹
        return this.fileImgMap.fold
      } else if (['jpg', 'png', 'jpeg'].includes(row.extendName)) {
        // 图片类型，直接显示缩略图
        return this.downloadImgMin(row)
      } else {
        const fileTypeMap = {
          pptx: 'ppt',
          doc: 'word',
          docx: 'doc',
          xls: 'excel',
          xlsx: 'excel'
        }
        //  可以识别文件类型的文件
        return this.fileImgMap[row.extendName] || this.fileImgMap[fileTypeMap[row.extendName]] || this.fileImgMap.other
      }
    },
    ...
}
</script>
```

刷新首页，看下文件列表数据回显效果：

![14-9](https://doc.shiyanlou.com/courses/3472/1557563/47dd366b98f4ef34c10fe030940309d3-0/wm)

大家可以找更多的文件类型图标来做映射。

## 存储空间统计

在左侧菜单底部，添加存储空间大小展示。

在 `src/request/file.js` 中添加接口：

```javascript
// 获取存储空间已占用大小
export const getFileStorage = (p) => get('/filetransfer/getstorage', p)
```

在 `src/views/Home/index.vue` 中每次获取表格列表数据时，调用此接口，获取存储空间大小，并将值传递给左侧菜单组件：

```vue
<template>
  <div class="home">
    <!-- 5. 传递给左侧菜单组件 -->
    <SideMenu class="home-left" :storageValue="storageValue"></SideMenu>
    <!-- 已有代码不再赘述 -->
    ...
  </div>
</template>

<script>
...
import { getFileStorage } from '@/request/file.js' //  1.引入接口

export default {
  name: 'Home',
  data() {
    return {
      storageValue: 0, //  存储空间占用大小
      ...
    }
  },
  methods: {
    // 获取文件列表
    getFileData() {
      this.loading = true // 打开表格loading状态
      if (this.fileType === 0) {
        // 左侧菜单选择的为 全部 时，根据路径，获取文件列表
        this.loading = false
        this.getFileDataByPath()
      } else {
        // 左侧菜单选择的为 除全部以外 的类型时，根据类型，获取文件列表
        this.getFileDataByType()
      }
      this.getStorageValue() //  2.调用获取文件占用空间函数
    },
    // 获取文件占用空间
    getStorageValue() {
      getFileStorage().then((res) => {
        //	3. 调用接口
        if (res.success) {
          this.storageValue = res.data ? res.data : 0 //	4.赋值
        } else {
          this.$message.error(res.message)
        }
      })
    },
    ...
  }
}
</script>
```

在左侧菜单组件 `SideMenu.vue` 中添加存储空间展示区，并使用 Element UI 的[进度条组件](https://element.eleme.cn/#/zh-CN/component/progress#zi-ding-yi-yan-se)来展示空间已使用占比，数据处理使用过滤器：

```vue
<template>
  <el-menu
    class="side-menu"
    :default-active="activeIndex"
    :router="true"
    :collapse="isCollapse"
    background-color="#545c64"
    text-color="#fff"
    active-text-color="#ffd04b"
  >
    <!-- 已有代码不再赘述，存储空间展示区，当左侧菜单收缩时，隐藏此区域 -->
    ...
    <div class="storage-wrapper" v-show="!isCollapse">
      <el-progress :percentage="storagePercentage" :color="storageColor" :show-text="false"></el-progress>
      <div class="text">
        <span>存储</span>
        <span>{{ storageValue | storageTrans }} / {{ storageMaxValue | storageTrans(true) }}</span>
      </div>
    </div>
  </el-menu>
</template>

<script>
export default {
  name: 'SideMenu',
  props: {
    storageValue: {
      type: Number,
      required: true
    }
  },
  data() {
    return {
      storageMaxValue: Math.pow(1024, 3) * 1, //  最大存储容量，1GB
      //  自定义进度条颜色，不同占比，进度条颜色不同
      storageColor: [
        { color: '#67C23A', percentage: 50 },
        { color: '#E6A23C', percentage: 80 },
        { color: '#F56C6C', percentage: 100 }
      ]
    }
  },
  computed: {
    ...
    // 存储百分比
    storagePercentage() {
      return (this.storageValue / this.storageMaxValue) * 100
    }
  },
  ...
  filters: {
    // 计算空间占比
    storageTrans(size, status) {
      const B = 1024
      const KB = Math.pow(1024, 2)
      const MB = Math.pow(1024, 3)
      const GB = Math.pow(1024, 4)
      if (status) {
        //	截取整数部分
        if (!size) {
          return 0 + 'KB'
        } else if (size < KB) {
          return (size / B).toFixed(0) + 'KB'
        } else if (size < MB) {
          return (size / KB).toFixed(0) + 'MB'
        } else if (size < GB) {
          return (size / MB).toFixed(0) + 'GB'
        } else {
          return (size / GB).toFixed(0) + 'TB'
        }
      } else {
        if (!size) {
          return 0 + 'KB'
        } else if (size < KB) {
          return (size / B).toFixed(0) + 'KB'
        } else if (size < MB) {
          return (size / KB).toFixed(2) + 'MB'
        } else if (size < GB) {
          return (size / MB).toFixed(3) + 'GB'
        } else {
          return (size / GB).toFixed(4) + 'TB'
        }
      }
    }
  },
  ...
}
</script>

<style lang="stylus" scoped>
.side-menu {
  // 已有代码不再赘述
  ...
  // 存储空间展示区
  .storage-wrapper {
    position: absolute;
    bottom: 0;
    left: 0;
    box-sizing: border-box;
    width: 100%;
    padding: 16px;
    z-index: 2;
    color: #fff;
    opacity: 0.8;

    .text {
      margin-top: 8px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 14px;
    }
  }
}
...
</style>
```

刷新首页，看下效果：

![14-10](https://doc.shiyanlou.com/courses/3472/1557563/caf2ab7a094f260c015693556c328703-0/wm)

## 实验总结

此次实验介绍了文件夹添加功能，使用 `vue-simple-uploader` 插件实现了文件的分片上传、秒传和断点续传，完善了表格列数据的回显，并添加了存储空间展示区域。插件的使用、界面的展示，大家可以根据自己的想法来封装和实现，对于成熟的技术，在会运用的基础上去研究其原理才有意义。

本次实验完整代码可以通过如下命令进行下载：

```bash
wget https://labfile.oss.aliyuncs.com/courses/3472/code14.zip
```
